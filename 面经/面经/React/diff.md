## 1.状态改变后会怎么样?/讲一下diff

在初始化时，React 调用 `render()` 方法，会创建一棵由 React 元素组成的树。在下一次 **`state`** 或**` props`** 更新时，相同的 `render()` 方法会返回一棵不同的树。React 需要基于这两棵树(两个虚拟DOM)之间的差别来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步。

一开始是**`Tree diff`**：对新旧两棵树之间进行逐层对比，`找出哪些节点需要更新`。如果节点是`组件`进行`Component diff`，如果节点是`标签`进行`Element diff`

这样命名是因为diff过程是递归的，描述比较方便

在**`Component diff`**里，先`对比组件的类型`，如果类型都不同，记录这个替换或者是删除的操作，然后结束该层的递归，不对比后面的了；如果只是`属性不同`，那么更新属性，然后深入组件进行递归Tree diff；如果都一样，深入组件进行递归Tree diff

在**`Element diff`**里，先`对比标签名`，如果标签名不同，记录这个替换或是删除的操作，然后结束该层递归，不对比后面的了；如果只是`属性不同`，那么更新属性，然后进入标签后代进行递归Tree diff；如果都一样，进入标签后代进行递归Tree diff



## 2.为什么用虚拟DOM

虚拟DOM是一个对象，通常包含有标签名，属性和子元素等等

在性能方面，虽然`虚拟DOM操作DOM肯定没有原生JS操作DOM快`，但是它可以`减少DOM操作的次数`。首先是可以**`将多次操作合并为一次操作`**，比如新增1000个节点，JS是一个接着一个节点进行操作的，而虚拟DOM是一次性操作1000个节点。同时虚拟DOM还可以**`借助diff算法将多余的操作省掉`**，比如这1000个节点里其实只有10个新增的，那么虚拟DOM只会操作这10个节点。如果数据量巨大，有上万的列表渲染在页面上却只需要更改其中的一两条数据，当然用虚拟DOM效率会很高。但如果数据内容变化非常大，大到差量更新和全量更新极为接近，或者就已经是全量更新了，那上万条的遍历、递归也够 diff 喝一壶。

但虚拟DOM的价值不仅仅是性能，虽然性能不是最优解，我们用虚拟DOM一般都是在框架里使用的，能够让性能还过得去，同时提升开发效率。

另外**`虚拟DOM可以跨平台`**，因为虚拟DOM本质是一个js对象，是`对渲染内容的一层抽象描述`，这就`使得视图层和渲染层做了解耦`。这层对渲染层的描述可以是 web、native、小程序等多端的，在不同端可能只需要一份代码就可以 work 。不仅可以变成DOM，还可以变成小程序、安卓应用等等



## 3. React 代码如何变成真实 dom 的

1. 首先jsx写的代码会被`babel`编译成js代码，以React.createElement函数形式存在。

1. `React.createElement`接收三个参数，第一个参数type用于标识节点的类型是标签还是组件，第二个参数是一个对象，标签或组件的所有属性以键值对的形式存储在该参数中，第三个参数是子元素。子元素也可能是React.createElement。因此会有多层嵌套。
2. React.createElement返回的结果是一个虚拟节点，最终会得到一个虚拟DOM。然后通过`ReactDOM.render()`方法形成真实DOM
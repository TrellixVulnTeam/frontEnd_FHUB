#    第一章 快速入门

## 0、TypeScript简介

1. TypeScript是JavaScript的超集。
2. 它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。
3. TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。
4. TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。
5. 相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。
5. 更早的发现错误，减少找Bug，改Bug，提升开发效率
5. 显示标记出代码中的意外行为，从而降低了发生错误的可能性



## 1、TypeScript 开发环境搭建

1. 下载Node.js
   - 64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi
   - 32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi

2. 安装Node.js

3. 使用npm全局安装typescript
   - 进入命令行
   - 输入：`npm i -g typescript`

4. 创建一个ts文件

5. 使用tsc对ts文件进行编译
   - 进入命令行
   - 进入ts文件所在目录
   - 执行命令：`tsc xxx.ts`
   - 执行完毕后，生成xxx.js文件

6. 执行js代码，在终端输入命令 `node hello.js`

   ![image-20220623113529077](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220623113529077.png)

## 补充

### 1. 使用ts-node简化运行ts的步骤

通过上面的描述，运行ts代码需要连续的执行两个命令，有些繁琐，可以使用`ts-node`进行简化

- 安装命令

``` bash
npm i -g ts-node
```

- `ts-node`包提供了ts-node命令，相当于前面两个命令的合并，接下来就可以直接采用命令执行运行ts文件

``` bash
ts-node xxx.ts
```

但是有可能出现以下问题

![image-20220623120519726](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220623120519726.png)

这是因为缺少`tsconfig.json`文件，当前的语法中es6的配置没有，需要我们用一个命令初始化`tsconfig.json`文件

``` bash
tsc --init #初始化一个配置，此配置会给我们加一个es6的指向，错误就不再有了
```

### 2. 解决两个文件之间的变量名冲突

- 问题：==在非模块化环境下，TS会把.ts文件中声明的变量当做全局变量==。所以，当两个.ts文件中声明的变量名称相同并且在VSCode中同时打开这两个文件时，VSCode会提示报错。
- 解决方法：==在.ts文件中添加`export{}`==
- 解释：
  - 当TS看到export这样的模块化语法后，就会将该文件当做模块来解析，此时再声明的变量就是该模块中的局部变量了
  - ==export无需导出任何内容==，该代码的作用仅仅是为了让ts知道这是模块化环境

## 2、基本类型

### 2.1 **`类型声明(类型注解)`**

- 类型声明是TS非常重要的一个特点。约束了只能给该变量赋值该类型的值

- 通过类型声明可以`指定TS中变量（参数、形参）的类型`

- 指定类型后，当`为变量赋值时`，TS编译器会`自动检查值是否符合类型声明`，符合则赋值，否则报错

- 简而言之，**`类型声明给变量设置了类型，使得变量只能存储某种类型的值`**

- 类型也可以是==类==

- 语法：

  - ```typescript
    let 变量: 类型 | 值; //注意其与 let 变量 = 值的区别，let 变量: 值类似于 const 变量 = 值，限制了变量
    
    let 变量: 类型 = 值;  
    
    let 变量 = 值; //TS解析会根据值自动判断变量的类型
    
    function fn(参数: 类型, 参数: 类型): 类型{ //最右侧的类型指定返回值的类型
        ...
    }
    ```

- **`自动类型判断`**

  - TS拥有自动的类型判断机制
  - 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型
  - 所以如果你的`变量的声明和赋值时同时进行`的，可以`省略掉类型声明`

### 2.2 具体类型：

|  类型   |       例子        |                   描述                    |
| :-----: | :---------------: | :---------------------------------------: |
| number  |    1, -33, 2.5    |                 任意数字                  |
| string  | 'hi', "hi", `hi`  |                任意字符串                 |
| boolean |    true、false    |             布尔值true或false             |
| 字面量  |      其本身       | `限制变量的值就是该字面量的值，类似const` |
|   any   |         *         |                 任意类型                  |
| unknown |         *         |               类型安全的any               |
|  void   | 空值（undefined） |           没有值（或undefined）           |
|  never  |      没有值       |               不能是任何值                |
| object  |  {name:'孙悟空'}  |               任意的JS对象                |
|  array  |      [1,2,3]      |                任意JS数组                 |
|  tuple  |       [4,5]       |      元素，TS新增类型，固定长度数组       |
|  enum   |    enum{A, B}     |            枚举，TS中新增类型             |
|  null   |       null        |                  空对象                   |

以上类型具体可以分为两类

#### 2.2.1 JS已有类型

1.  原始类型：`number/string/boolean/null/undefined/symbol`

   1. ##### number

      1. ``` typescript
         let decimal: number = 6;
         let hex: number = 0xf00d;
         let binary: number = 0b1010;
         let octal: number = 0o744;
         let big: bigint = 100n;
         ```

   2. ##### string

      1. ``` typescript
         let color: string = "blue";
         color = 'red';
         
         let fullName: string = `Bob Bobbington`;
         let age: number = 37;
         let sentence: string = `Hello, my name is ${fullName}.
         
         I'll be ${age + 1} years old next month.`;
         ```

   3. ##### boolean

      1. ``` typescript
         let isDone: boolean = false;
         ```

   4. ##### null

      1. ``` typescript
         let nullType: null = null;
         ```

   5. ##### undefined

      1. ``` typescript
         let undeType: undefined = undefined
         ```

   6. ##### symbol

      1. ``` typescript
         let unique: symbol = Symbol()
         ```

      2. 

2. 对象类型：`object`(数组、对象、函数等等)

   1. ##### 数组array

      1. `类型[]`写法

         1. ``` typescript
            let userList: string[] = ['John', 'Bob', 'Tony']
            let peopleList: object[] = [{name: '张三', age: 18}];
            ```

      2. `Array<类型> `写法

         1. ``` typescript
            let user2List: Arrary<string> = ['John', 'Bob', 'Tony']
            let people2List: Arrary<object> = [{name: '张三', age: 18}];
            ```

   2. ##### 对象 object

      1. 对象中的属性采用`属性名: 类型`形式来描述，函数可以采用`方法名: 返回值类型`或者`函数名: Function`(不指定返回值)或者`方法名: ()=>返回值类型`来进行描述

         1. 直接定义类型

            1. ``` typescript
               //1.函数名: Function
               let person1: {
                   username: string,
                   age: number,
                   run: Function
               } = {
                   username: '老高',
                   age: 32,
                   run: function(){
                       console.log('老高快跑')
                   }
               }
               
               //2.方法名: 返回值类型
               let person2: {
                   username: string,
                   age: number,
                   run(): string
               } = {
                   username: '老高',
                   age: 32,
                   run(){
                       return '123';
                   }
               }
               
               //3.方法名()=>返回值类型
               let person3: {
                   username: string,
                   age: number,
                   run: ()=> string
               } = {
                   username: '老高',
                   age: 32,
                   run(){
                       return '123';
                   }
               }
               
               ```
   
         2. ==先用自定义类型来定义对象类型，再声明对象==
   
            1. ``` typescript
               type FuncType = (num1: number, num2: number) => number
               type ObjType = {
                   username: string,
                   age: number,
                   run: FuncType
                   // run: () => string 可以指定返回值类型
                   // run: Function 无法指定返回值类型
                   // run(): string可以指定返回值类型
               }
               let person = {
                   username: 'Ash',
                   age: 32,
                   run: (num1: number, num2: number) =>{
                   	return num1 + num2;
               	}
               }
               
               console.log(person.run());
               ```
   
      2. 对象可选属性
   
         1. 用`?`
   
            1. ```  typescript
               type ObjType = {
                   username?: string,
                   age: number,
                   run: FuncType
                   // run: () => string 可以指定返回值类型
                   // run: Function 无法指定返回值类型
                   // run(): string可以指定返回值类型
               }
               let person = {
                   age: 32,
                   run: (num1: number, num2: number) =>{
                   	return num1 + num2;
               	}
               }
               ```
   
      3. `[propName: string]: any` 表示任意个任意类型的属性
   
         1. ``` typescript
            let c: {name: string, [propName: string]: any};
            c = {name: '猪八戒', age: 18, gender: '男'};
            ```
   
         2. **`&`** 表示同时
   
            -  必须要都包含才行
            -  有点鸡肋
   
      4. 
   
   3. ##### 函数function
   
      1. 重点：要指定函数==参数==和==返回值==的类型
   
      2. 两种写法：
   
         1. 在==声明函数==时，指定参数和返回值的类型
   
            1. ``` typescript
               // 普通函数声明
               function add(num1: number, num2: number): number{
                   return num1 + num2
               }
               add(1, 2)
               
               // 箭头函数声明
               const add2 = (num1: number, num2: number): number=>{
                   return num1 + num2;
               }
               add2(1, 2)
               ```
   
         2. ==先指定一类函数的类型==，然后在声明函数
   
            1. ``` typescript
               // 指定这一类函数，参数和返回值都是number类型
               // 一旦用上了type关键字，此时我们代码处于类型上下文 => 遵循ts的语法规范以及运行守则
               type FuncType = (num1: number, num2: number) => number
               //类型兼容性，所以即使add3缺少参数，在声明的时候不会报错，但如果调用的时候参数不够会报错
               const add3: FuncType = ()=>{
                   return 123;
               }
               add3(1,2) //不报错
               add3() //报错
               
               const add4: FuncType = (num1: number, num2: number) =>{
                   return num1 + num2;
               }
               ```
   
      3. 设置参数可选
   
         1. 应用场景：定义函数时，有的参数可传可不传。利用`type`定义完函数的类型后，在定义函数时即使不具有类型里要求的参数，定义时也不会报错，但是在调用时会报错；但如果将参数设置为可选后，无论是定义函数时还是调用函数时都不会报错。
   
         2. ==?==表示==该参数或者变量可传可不传==
   
            1. 比如，在使用数组的`slice`方法时，我们可以直接使用`slice()`，也可以传入参数`slice(1)`，也可以`slice(1, 3)`
   
               1. ``` typescript
                  const slice = (num: number, start?: number, end?: number): void => {};
                  ```
   
         3. 注意：==可选参数必须处于必须参数的后面==

#### 2.2.2 TS新增类型

1. 联合类型、自定义类型(类型别名)、接口、元组、字面量类型、枚举、void、any等

   1. ##### 联合类型

      1. 应用场景：变量既可以赋值为number，又可以赋值为string或者说数组中既有number类型，又有string类型

      2. ==变量既可以赋值为number，又可以赋值为string==

         1. ``` typescript
            let str: string | number = 1;
            str = '张三'
            
            //既可以是字符串数组，也可以是数字数组
            let arr: string[] | number[] = [1,2,3,4];
            arr = ['a', 'b', 'c']
            ```

      3. ==数组中的元素既可以是string类型，也可以是number类型==

         1. ``` typescript
            let arr1: (string | number)[] = [1,2,3,'a'];
            let arr2: Array<string | number> = [1,2,3,'a'];
            ```

   2. ##### 自定义类型

      1. 应用场景：当==一个复杂类型或者脸型类型过多或者被频繁使用==时，可以通过类型别名来简化该类型的使用

      2. 用法：`type 名称 = 具体类型`

         1. ``` typescript
            //复杂类型被频繁使用
            let arr: (number | string)[] = [1,2,3,'4'];
            let arr1: (number | string)[] = [1,2,3,'4'];
            let arr2: (number | string)[] = [1,2,3,'4'];
            
            //自定义类型
            type CustomArr = (number | string)[]
            // type CustomArr = (num1: number, num2: number) => number
            
            let arr3: CustomArr = [1,2,'3'];
            ```
   
      3. 补充
   
         1. `type`是创建自定义类型的关键字
         2. 类型别名可以是任意合法的变量名称
         3. 推荐==大驼峰==的命名写法
   
   3. ##### void类型
   
      1. 应用场景：当想要定义的函数没有返回值时，可用关键字`void`表示
   
         1. ``` typescript
            // 先定义函数的类型
            type FuncType = (num1: string, num2: string) => void
            // 再声明函数
            const func1 = (num1: string, num2: string)=>{
            	// 因为类型兼容性的存在，即使有返回值，也不会报错
                return num1 + num2;
            }
            
            //如果不写返回值的类型，则默认是void
            const add5 = () => {
                
            }
            // add5等价于下面的add6
            const add6 = (): void => {}
            
            // 如果指定返回值为undefined 则需要返回undefined
            const add7 = (): undefined => {
                return undefined;
            }
            ```
   
   4. ##### 接口interface 
   
      1. 当一个==对象==类型被多次使用时，一般使用接口(interface)描述对象的类型，达到复用的目的。
   
      2. 使用`interface`关键字来声明接口；接口名称推荐以`I`为开头；声明接口之后，直接使用接口名称作为变量的类型。
   
         1. ``` typescript
            interface IPeople {
                username?: string,
                age?: number,
                run?: () => void  // 函数的参数和返回值类型
            }
            
            let p1: IPeople = {
                username: '123'
            }
            
            interface ILength {
                length: number
            }
            
            // 只要声明的变量有length这个属性，那么数组也可以
            let arr3: ILength = [1, 2, 3];
            ```
   
      3. ==接口和自定义类型的区别==
   
         1. 相同点：都可以给对象指定类型
   
         2. 不同点：==接口只能为对象指定类型，类型别名可以为任意类型指定别名==
   
         3. 推荐用自定义类型type
   
            1. ``` typescript
               // interface I接口名称{}
               // type CustomFunc = {}
               ```
   
      4. ==接口继承==
   
         1. 如果两个接口之间有相同的属性和方法，可以==将公共的属性和方法抽离出来，通过继承来实现复用==
   
            1. 比如
   
               1. ``` typescript
                  interface IPoint2D{
                      x: number,
                      y: number
                  }
                  
                  interface IPoint3D{
                      x: number,
                      y: number,
                      z: number
                  }
                  ```
   
            2. ==更好的方式==
   
               1. ``` typescript
                  interface IPoint2D{
                      x: number,
                      y: number
                  }
                  
                  interface IPoint3D extends IPoint2D {
                      z: number
                  }
                  
                  let p4: IPoint3D = {
                      x:1,
                      y:1,
                      z:1
                  }
                  ```
   
   5. ##### 元组 tuple
   
      1. 元组就是==定义了每个元素的具体类型以及长度固定==的数组。它确切知道==包含多少个元素==，以及特定==索引对应的类型==。==在数组的具体位置定义类型==
   
      2. 语法：`[类型, 类型, 类型]`
   
      3. ``` typescript
         let position: [string, number] = ['1', 1]
         ```
   
   6. ##### 字面量类型
   
      1. 一个==固定的值==，任意的JS字面量(对象，数组，数字)都可以作为类型使用。在几个固定的值之间做选择
   
      2. ==使用场景和模式==
   
         1. 使用模式：==字面量类型配合联合类型一起使用==
   
         2. 使用场景：用来==表示一组明确的可选值列表==
   
         3. ``` typescript
            let color: 'red' | 'blue' | 'black';
            let num: 1 | 2 | 3 | 4 | 5; 
            let str： “王五" | "赵六" = "赵六"
            ```
   
   7. ##### 枚举 enum
   
      1. 枚举的功能类似于==字面量+联合类型组合==的功能，也可以==表示一组明确的可选值==
   
      2. 枚举：定义==一组命名常量==，它描述一个值，该==值可以是这些命名常量中的一个==。
   
         1. eg：枚举的成员是有值的，默认从0开始自增的数值
   
         2. ``` typescript
            // 创建枚举, Up ->0, Down ->1, Left ->2, Right ->3
            enum Direction2 {
                Up,
                Down,
                Left,
                Right
            }
            
            // 使用枚举类型
            function changeDirection2(direction: Direction2){
                console.log(direction) //打印0
            }
            
            //应传入枚举Direction成员的任意一个
            //直接通过点(.)语法访问枚举的成员
            changeDirection2(Direction2.Up);
            ```
   
      3. ==数字枚举==
   
         1. 枚举的成员是幼稚的，默认为：从0开始自增的数值
   
         2. 把==枚举成员的值为数字的枚举==，称为数字枚举。当然，也可以给枚举中的成员初始化值
   
            1. ``` typescript
               // Down ->11, Left -> 12, Right -> 13
               enum Direction {
                   Up = 10,
                   Down,
                   Left,
                   Right
               }
               
               enum Direction {
                   Up = 2,
                   Down = 4,
                   Left = 8,
                   Right = 16
               }
               ```
   
      4. ==字符串枚举==
   
         1. 枚举成员的值是字符串
   
         2. 注意：字符串枚举没有自增长行为，因此，==字符串枚举的每个成员必须有初始值==
   
         3. ``` typescript
            // 创建枚举, 
            enum Direction2 {
                Up = 'UP',
                Down = 'DOWN',
                Left = 'LEFT',
                Right = 'RIGHT'
            }
            
            // 使用枚举类型
            function changeDirection2(direction: Direction2){
                console.log(direction) //打印0
            }
            
            //应传入枚举Direction成员的任意一个
            //直接通过点(.)语法访问枚举的成员
            changeDirection2(Direction2.Up);
            ```
   
   8. any 类型
   
      1. 原则：==不推荐使用any==，相当于关闭了ts的类型检测
   
      2. 当变量的类型为any是，变量可以是任意值，不会有代码提示
   
         1. ``` typescript
            let d: any = 4;
            d = 'hello';
            d = true;
            
            let e; //声明变量如果不指定类型，则TS解析器会自动判断变量的类型为any(隐式的any)
            ```
   
      3. 当有ts异常时，any可以解决任意的问题，any类型可以作为一个临时的解决方案
   
      4. 其它==隐式具有any类型==的情况
   
         1. 声明变量既不提供类型也不提供默认值
         2. 函数参数不加类型
   
      5. 注意：因为不推荐使用any，所以这两种情况下都应该提供类型。

### 2.3 类型推论

1. 常见场景

   1. 声明变量，并给了一个初始值
   2. 函数返回值

2. ts会==自动推断具有初始值的变量和函数返回值的类型==。无需再表示类型

   1. ``` typescript
      // 变量username自动被推断为string
      let username = 'goly'
      
      // 函数返回值的类型被自动推断为number
      function addCount(num1: number, num2: number){
          return num1 + num2;
      }
      ```

3. 推荐：==能省略类型注解的地方就省略==

> 对象类型在TS中更加细化，每个具体对象都有自己的类型语法

### 2.4 类型断言

- 有时候程序员可能比ts更明确一个变量的类型，ts的类型推论不够精确，所以要使用==类型断言==来强制转换为==更具体==的类型

- ``` typescript
  const aLink = document.getElementById('link')
  ```

  - 注意：该方法的返回值的类型时HTMLElement，该类型只包含所有标签公共的属性或方法，不包含a标签特有的href等属性。类型推论不够精确。

  - 因此，这个==类型太宽泛(不具体)==，无法操作href等a标签特有的属性或方法

  - 解决方式：这种情况下就需要==使用类型断言指定更加具体的类型==

    - ``` typescript
      const aLink = document.getElementById('link') as HTMLAnchorElement
      ```

  - 解释：

    1. 使用`as`关键字实现类型断言
    2. 关键字`as`后面的类型是一个==更加具体的类型==(HTMLAnchorElement时HTMLElement的子类型)
    3. 通过类型断言，aLink的类型变得更加具体，这也就可以访问a标签特有的属性或方法了。

- 另一种语法：使用`<>`语法，该语法知道即可，在react的jsx中使用会报错

  - ``` typescript
    const aLink = <HTMLAnchor>document.getElementById('link') 
    ```

- 另一种使用方式（==更改变量的类型==）

  - ``` typescript
    type CustObj = {
        name: string,
        age: number
    }
    type CustObj2 = {
        name: string,
        age: number,
        sex: string
    }
    
    let people: CustObj = {
        name: 'Ash',
        age: 12
    }
    
    people = {
        name: 'Ash',
        age: 12,
        sex: 'female'
    } as CustObj2
    ```

### 2.5 typeof

- 在`js`中，typeof操作符用于获取数据的类型

  - ``` typescript
    console.log(typeof "Hello world") //string
    ```

- 在`ts`中，typeof操作符，可以在类型上下文中引用变量或属性的类型(类型查询)

- 使用场景：==根据已有变量的值，获取该值的类型，来简化类型书写==。这样就能使得在定义了一个变量后，我们想再定义一个变量，就可以使用`typeof`让==新变量与旧变量拥有同一类型，而无需再自定义类型==

  - ``` typescript
    let p = {x: 1, y: 2}
    //下面两种写法等价, 参数point的类型是一个对象
    function formatPoint(point: {x: number, y: number})
    function formatPoint(point: typeof p)
    
    let new_p: typeof p ={
        x:3,
        y:4
    }
    ```

- 解释：

  1. 使用`typeof`操作符来获取变量`p`的类型，结果与上一行直接用对象字面量形式定义类型的方式一样
  2. `typeof`出现在==类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文==(区别于JS代码)
  3. 注意：==typeof只能用来查询变量或属性的类型==，无法查询其它形式的类型

### 2.6 类型兼容性

> ts采用的是结构化类型系统，类型检查关注的是值所具有的形状。

#### 2.6.1 对象类型兼容性(**==将一个对象变量赋值给另一个对象变量==**)

- 如果两个对象具有==相同的形状==，则认为它们属于==同一类型==

  - ``` typescript
    type custom_obj = {
        name: string,
        age: number
    }
    type custom_obj2 = {
        name: string,
        age: number
    }
    
    let p1: custom_obj = {
        name: 'Ash',
        age: 21
    }
    let p2: custom_obj2 = p1 
    ```

- 对于对象类型来说，因为是将p1赋值给p2，而p1的类型是`custom_obj`，p2的类型是`custom_obj2`，==p1需要至少有p2的所有属性，满足必须的类型，而多定义了的属性也没事==

  - ``` typescript
    type custom_obj = {
        name: string,
        age: number,
        sex: string
    }
    type custom_obj2 = {
        name: string,
        age: number
    }
    
    let p1: custom_obj = {
        name: 'Ash',
        age: 21,
        sex: 'female'
    }
    let p2: custom_obj2 = p1 // 这个不会报错
    
    let p2: custom_obj2 = {   // 这样会报错，这样的赋值必须是满足
        name: 'Ash',
        age: 21,
        sex: 'female'
    }
    ```

#### 2.6.2 函数类型兼容性

- 需要考虑：==1.参数个数；2.返回值类型等等==

- 参数个数：参数多的兼容参数少的，==参数少的可以赋值给多的==

  - 在js中省略用不到的参数(例如数组slice方法的三种使用方式)实际上非常常见，这样的使用方式促成了ts中函数类型之间的兼容性。

  - ``` typescript
    type F1 = (a: nunmber) => void;
    type F2 = (a: number, b: number) => void;
    
    let f1: F1 = (a: number) => {};
    let f2: F2 = f1;
    ```

- 返回值类型：只要满足必须的类型要求，多了也没事。即使返回的类型不对也不会造成任何影响

  - ``` typescript
    type F1 = ()=>void;
    let f1: F1 = ()=>{
        return 213;
    }
    ```


### 2.7 泛型

- 泛型可以==在保证类型安全的前提下==，让函数等与多种类型一起工作，==从而实现复用==。常用于：==函数、接口、class中==

- 可以==在函数或者对象接口中使用多种类型来进行统一的业务逻辑处理==。

- 例子

  - 需求：创建一个id函数，传入什么数据就返回该数据本身(参数和返回值类型相同)

    - ``` typescript
      function id(value: number): number{
          return value;
      }
      
      // res => 10
      const res = id(10)
      ```

  - 比如，id(10)调用以上函数就会直接返回10本身。但是，该函数只能接收数值类型，无法用于其它类型

  - 而如果将参数类型修改为any，这样就失去了ts的类型保护，类型不安全

    - ``` typescript
      function id(value: any): any{
          return value;
      }
      ```

  - 在这种情况下，就可以使用==泛型==来实现了

    - ``` typescript
      function id <T>(value: T): T{
          return value
      }
      ```

#### 2.7.1 泛型函数

##### 1.==创建==泛型函数

1. ``` typescript
   // 1. 直接声明函数
   function id <T>(value: T): T{
       return value
   }
   
   // 2. 先定义函数的类型，再声明函数 
   type CustomFunc = <T>(value: T, value2: T) => T
   let func: CustomFunc = (value) =>{
       return value
   }
   let num: string = func<string>("123")
   ```

2. 解释：

   1. 语法：在函数名称的后面添加`<类型变量>`，比如这里的类型变量就是T
   2. 类型变量T是==一种特殊类型的变量，它处理类型而不是值==
   3. 类型变量相当于一个类型容器，能够==捕获用户提供的类型==（==具体什么类型由用户调用该函数时指定，可以是任意类型==）
   4. 因为T是类型，所以可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型
   5. 类型变量T，可以是任意合法的变量名称

##### 2.==调用==泛型函数

1. ``` typescript
   // 参数和返回值类型都为number
   const num = id<number>(10);
   
   // 参数和返回值类型都为string
   const str = id<string>('a');
   ```

2. 解释

   1. 在调用时指定的具体类型是number
   2. 当传入类型number后，类型变量T会捕获到该传入类型
   3. 此时T就是number，所以参数和返回值的类型均为number
   4. 这样，==通过泛型就做到了让id函数与多种不同类型一起工作，实现了复用的同时保证了类型安全==

3. ==简化泛型函数调用==

   1. 在调用泛型函数时，==可以省略`<类型>`来简化泛型函数的调用==

      1. ``` typescript
         let num1 = id(10);
         let str1 = id('123');
         ```

      2. 解释

         1. 因为==类型推论==这种机制的存在，所以ts可以==根据传入的实参自动推断出类型变量T的类型==
         2. 比如，传入参数10，ts会自动推断出变量num的类型number，并作为T的类型
         3. 说明：==当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数==

##### 3.泛型约束

1. 为什么需要泛型约束

   1. 默认情况下，泛型函数的而类型变量T可以代表任意类型，这==导致无法访问任何属性==

   2. 例如

      1. 以下代码想要获取参数的长度，但是**因为T可以代表任意类型，无法保证一定存在length属性**，比如number类型就没有length属性。因此，无法访问length属性

         1. ``` typescript
            function id<T>(value: T): T{
                console.log(value.length)   //此处会报错
                return value
            }
            
            id('a');
            ```

   3. 此时就需要==为泛型添加约束来收缩类型==，缩窄类型取值范围

2. ==为泛型收缩类型==，有以下两种方式

   1. 指定更加具体的类型

      1. 比如将类型修改为`T[]`，表示T类型的数组，只要是数组就一定存在length属性，那么就可以访问了

         1. ``` typescript
            function id<T>(value: T[]): T[]{
                console.log(value.length)   //此处会报错
                return value
            }
            
            id('a');
            
            type CustomFun = <T>(value: T[]): T[]{
                
            }
            ```

         2. 

   2. ==添加泛型约束==

      1. 使用`extends`关键字来为泛型函数==添加类型约束==。extends表示继承，继承的意思就是父亲有的我都有，同时我可以有自己的东西

         1. ``` typescript
            // 创建一个自定义类型
            interface ILength {
                length: number
            }
            
            // 添加泛型约束语法： T extends ILength
            // 解释：表示传入的类型必须满足ILength接口的要求才行，也就是必须有一个number类型的length属性。
            function id<T extends ILength>(value: T): T{
                console.log(value.length);  //此处的value一定有length属性
                return value;
            }
            
            id([1,2,3]);
            id(1); //报错，因为数字1没有length属性。
            
            //
            type CustomFunc1 = <T extends ILength>(value: T): T => T
            let func3: CustomFunc1 = (value) => {
                console.log(value.length);
                return value;
            }
            func3("");
            func3([]);
            ```

      2. 解释

         1. 创建描述约束的接口ILength，==该接口要求提供length属性==
         2. 通过`extends`关键字来为泛型(类型变量)==添加约束==
         3. 该约束表示：**传入的类型必须具有length属性**
         4. 注意：==传入的实参只要有length属性即可==(比如数组)，类型兼容性。

##### 4.多个类型变量的泛型

- 泛型的类型变量可以有多个，并且==类型变量之间还可以约束==（比如，第二个类型变量受第一个类型变量约束）

###### 1.类型变量之间的约束

1. 例子1：创建一个函数来获取对象中属性的值

   1. ``` typescript
      function getProp<T, K extends keyof T>(obj: T, key: K){
          return obj[key];
      }
      
      let person = {name: 'Ash', age: 12};
      getProp(person, 'name') //输入除'name'和'age'外的其它字符串，会报错
      ```

2. 解释1

   1. 类型变量之间用`,`号隔开
   2. `keyof`关键字接收一个对象模型，生成其键名称(可能是字符串或数字)的联合类型。表示==属于后面对象的键中的一个值==。
   3. 示例中的`keyof T`实际上获取到的是person对象所有键的联合类型，也就是`'name' | 'age'`
   4. 类型变量K受T约束，可以理解为：K只能是T所有键中的任意一个，或者说只能访问对象中存在的属性

3. 例子2：在例子1的基础上限制T，因为T应该只能是一个对象

   1. ``` typescript
      // T extends object 表示：T应该是一个对象类型；如果不是，会报错
      // 注意是小写的object
      function getProp<T extends object, K extends keyof T>(obj: T, key: K){
          return obj[key];
      }
      
      let person = {name: 'Ash', age: 12};
      getProp(person, 'name') //输入除'name'和'age'外的其它字符串，会报错
      ```

#### 2.7.2 泛型接口

- 接口interface与泛型配合使用。

- 1. 例子

     1. ``` typescript
        // 以下三个接口结构都非常相似，只是类型不同，所以可以用泛型来简化
        interface IdFunc {
            id: (value: string) => string,
            ids: () => string[]
        }
        
        interface IdFunc2 {
            id: (value: number) => number,
            ids: () => number[]
        }
        
        interface IdFunc2 {
            id: (value: object) => object,
            ids: () => object[]
        }
        ```

     2. ``` typescript
        interface IdFunc <T>{
            id: (value: T) => T,
            ids: () => T[]
        }
        
        let obj: IdFunc<number> = {
            id(value) {
            	return value;
        	},
            ids: ()=>{
                return [1,2,3,4]
            }
        }
        
        // 调用obj.id时，因为规定了参数value的类型也为T，所以在这里必须是number
        obj.id(123);
        ```

  2. 解释：

     1. 在接口名称的后面添加`<类型变量>`，那么这个接口就变成了泛型接口
     2. 接口的类型变量，对接口中所有其它成员可见，也就是==接口中所有成员都可以使用类型变量==
     3. ==使用泛型接口时，需要显式指定具体的类型==

#### 2.7.3 泛型工具类型

- ts内置了一些常用的工具类型，来简化ts中的一些常见操作。这些工具都是基于泛型实现的(泛型适用于多种类型，更加通用)，并且是内置的，主要学习以下以下几个
- 下述类型，`interface`和`type`均可

##### 1. Partial<T>

- Partial用来构造一个类型，==将Type的所有属性设置为可选==。

  - ``` typescript
    type Props = {
        id: string,
        age: number
    }
    
    type partail_Props = Partial<Props>;
    let people: partail_Props = {}
    ```

- 解释：构造出来的新类型==partail_Props结构和Props相同==，但所有==属性都变为可选==的。

##### 2. Readonly<T>

- Readonly用来构造一个类型，==将Type的所有属性设置为只读==。

  - ``` typescript
    type Props = {
        id: string,
        age: number
    }
    
    type readonly_Props = Readonly<Props>;
    let people2: readonly_Props = {
        id: '123',
        age: 23
    }
    
    people2.age =13   //这行代码在写代码阶段就会报错
    ```

- 解释：构造出来的新类型==readonly_Props结构和Props相同==，但所有==属性都变为可选==的。当我们在声明完`people2`这个变量后，再想重新给`people2`的属性赋值时，就会报错，因为它是只读属性

##### 3. Pick<T,Keys>

- ==从T中选择一组属性来构造新类型==

  - ``` typescript
    type Props = {
        id: string,
        age: number,
        sex: string
    }
    
    type pick_props = Pick<Props, 'id' | 'age'>;
    let people3: pick_props = {
        id: 'Ash',
        age: 23
    }
    ```

- 解释：

  - 有两个变量：==1.选择谁的属性；2.选择哪几个属性==
  - 第二个变量，==如果有多个属性想选择，使用联合类型即可==
  - 第二个变量的属性只能是第一个Type中存在的属性
  - 构造出来的`pick_props`，只有`id`和`age`两个属性类型

- unknown

- - ```typescript
    let notSure: unknown = 4;
    notSure = 'hello';
    ```

- never

  - ```typescript
    function error(message: string): never {
      throw new Error(message);
    }
    ```


- `unknown 和 any的区别`

  - any`可以直接赋值`给任意类型的变量 

  - unknown`不能直接赋值`给其它变量。但有些时候，给unknown类型变量赋值后，我们是知道目前该变量的类型的。因此需要告诉编译器该变量的类型

    ``` typescript
    let e: unknown;
    e = "hello"
    let s: string;
    
    //法一：进行类型判断
    if(typeof e === "string"){
        s = e;
    }
    
    //法二：类型断言
    s = e as string;
    s = <string> e;
    ```

- **`声明函数`**的两种方式


    - 普通函数：直接写函数比较方便
    
      ``` typescript
      function fn(参数: 类型, 参数: 类型): 类型{ //最右侧的类型指定返回值的类型
          ...
      }
      ```



    - 箭头函数：先声明函数参数以及返回值的类型，然后再写函数里具体的逻辑操作
    
      ``` typescript
      let fn1: (a: number, b: number) => number;
      fn1 = (a, b) => a + b;
      ```



- **`类型的别名（自定义类型）`**

  - 常用于`自己设定一堆变量的取值范围`

  - `自定义类型`。如果用到这个`类型的变量少`的话，可以`直接字面量声明类型`；如果用到这个`类型的变量多`的话，可以将这个`类型进行自定义声明`，再对变量进行声明`


  ``` typescript
  type myType = 1 | 2 | 3 | 4 | 5;
  let k: myType;
  let l: myType;
  let m: myType;
  
  k = 2
  
  // 也可以定义多个对象具有同样的结构，可以先自定义一个对象的类型
  type myType = {
      name: string,
      age: number
  };
  
  const obj1: myType = {
      name: 'sss',
      age: 111
  }; 
  const obj2: myType = {
      name: 'aaa',
      age: 222
  }
  ```

  

## 3、编译选项

- 自动编译`指定文件`

  - 编译文件时，使用 `-w` 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。

  - 示例：

    - ```powershell
      tsc xxx.ts -w
      ```

- 自动编译`整个项目`

  - 如果直接使用**`tsc`**指令，则可以自动将`当前项目`下的所有ts文件编译为js文件。

  - 但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 **`tsconfig.json`**

  - tsconfig.json是一个JSON文件，添加配置文件后，只需只需 `tsc`命令即可完成对整个项目的编译

  - `tsc -w`则会使得TS编译器`监视`include指定文件的变化，并在文件发生变化时对文件进行重新编译。

  - 配置选项：

    - **`include`**

      - 定义`希望被编译文件所在的目录`

      - \*\*表示任意目录，*表示任意文件 

      - 默认值：["\*\*/\*"]，即项目所在的任意文件夹下的任意文件
  
      - 示例：
    
        - ```json
          "include":["src/**/*", "tests/**/*"]
          //表示src文件夹下的任意文件夹以及任意目录，即编译src文件夹下的任意文件
          ```
          
        - 上述示例中，所有src目录和tests目录下的文件都会被编译
    
    - **`exclude`**
    
      - 定义需要`排除在外的目录`
    
      - 默认值：["node_modules", "bower_components", "jspm_packages"]
    
      - 示例：
    
        - ```json
          "exclude": ["./src/hello/**/*"]
          ```
    
        - 上述示例中，src下hello目录下的所有文件都不会被编译
    
    - extends
    
      - 定义被继承的配置文件
    
      - 示例：
    
        - ```json
          "extends": "./configs/base"
          ```
    
        - 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息
    
    - files
    
      - 指定被编译文件的列表，只有需要编译的文件少时才会用到
    
      - 示例：
    
        - ```json
          "files": [
              "core.ts",
              "sys.ts",
              "types.ts",
              "scanner.ts",
              "parser.ts",
              "utilities.ts",
              "binder.ts",
              "checker.ts",
              "tsc.ts"
            ]
          ```
    
        - 列表中的文件都会被TS编译器所编译
    
      - **`compilerOptions`**
    
        - 编译选项是配置文件中非常重要也比较复杂的配置选项
    
        - 在compilerOptions中包含多个子选项，用来完成对编译的配置
    
          - 项目选项
    
            - `target`
    
              - 设置`ts代码编译成的js目标版本`
    
              - 可选值：
    
                - ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext
    
              - 示例：
    
                - ```json
                  "compilerOptions": {
                      "target": "ES6"
                  }
                  ```
    
                - 如上设置，我们所`编写的ts代码将会被编译为ES6版本的js代码`
    
            - lib
    
              - 指定代码运行时所包含的库（宿主环境）
    
              - 可选值：
    
                - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......
    
              - 示例：
    
                - ```json
                  "compilerOptions": {
                      "target": "ES6",
                      "lib": ["ES6", "DOM"],
                      "outDir": "dist",
                      "outFile": "dist/aa.js"
                  }
                  ```
    
            - `module`
    
              - 设置`编译后代码使用的模块化系统`
    
              - 可选值：
    
                - CommonJS、UMD、AMD、System、ES2020、ESNext、None
    
              - 示例：
    
                - ```typescript
                  "compilerOptions": {
                      "module": "CommonJS"
                  }
                  ```
    
            - `outDir`
    
              - `编译后文件的所在目录`
    
              - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置
    
              - 示例：
    
                - ```json
                  "compilerOptions": {
                      "outDir": "dist"
                  }
                  ```
    
                - `设置后编译后的js文件将会生成到dist目录`
    
            - outFile
    
              - 将所有的文件编译为一个js文件
    
              - 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中
    
              - 示例：
    
                - ```json
                  "compilerOptions": {
                      "outFile": "dist/app.js"
                  }
                  ```
    
            - rootDir
    
              - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录
    
              - 示例：
    
                - ```json
                  "compilerOptions": {
                      "rootDir": "./src"
                  }
                  ```
    
            - allowJs
    
              - 是否对js文件编译
              - 默认是false
          
            - checkJs
          
              - 是否对js文件进行检查是否符合ts语法规范
          
              - 默认值是false
          
              - 示例：
          
                - ```json
                  "compilerOptions": {
                      "allowJs": true,
                      "checkJs": true
                  }
                  ```
          
            - removeComments
    
              - 是否删除注释
              - 默认值：false
          
            - noEmit
    
              - 是否不对代码进行编译
              - 默认值：false
          
            - noEmitOnError
    
              - 当有错误时，是否不生成编译后的文件
              - 默认值：false
          
            - sourceMap
          
              - 是否生成sourceMap
              - 默认值：false
          
              
          
          - 严格检查
          
            - **`strict`**
              
              - 启用所有的严格检查，`默认值为false`，设置后相当于`开启了所有的严格检查`
            - alwaysStrict
              - 总是以严格模式对代码进行编译。设置编译后的文件是否使用严格模式
              - 默认false
            - noImplicitAny
              - 禁止隐式的any类型
              
              - 例如函数声明里的参数未说明类型
              
              - ``` typescript
                function (a, b){
                    return a + b
                }
            - noImplicitThis
              - 禁止类型不明确的this
            - strictBindCallApply
              - 严格检查bind、call和apply的参数列表
            - strictFunctionTypes
              - 严格检查函数的类型
            - strictNullChecks
              - 严格的空值检查
            - strictPropertyInitialization
              - 严格检查属性是否初始化
          
          - 额外检查
          
            - noFallthroughCasesInSwitch
              - 检查switch语句包含正确的break
            - noImplicitReturns
              - 检查函数没有隐式的返回值
            - noUnusedLocals
              - 检查未使用的局部变量
            - noUnusedParameters
              - 检查未使用的参数
          
          - 高级
          
            - allowUnreachableCode
              - 检查不可达代码
              - 可选值：
                - true，忽略不可达代码
                - false，不可达代码将引起错误
            - noEmitOnError
              - 有错误的情况下不进行编译
              - 默认值：false

## 4、webpack

- 通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。

- 步骤：

  1. 初始化项目

     - 进入项目根目录，执行命令 ``` npm init -y```
       - 主要作用：创建package.json文件

  2. 下载构建工具

     - ```npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin```
       - 共安装了7个包
         - webpack
           - 构建工具webpack
         - webpack-cli
           - webpack的命令行工具
         - `webpack-dev-server`
           - webpack的开发服务器，自动启动。`需要在package.json中配置启动指令`
         - typescript
           - ts编译器
         - ts-loader
           - ts加载器，用于在webpack中编译ts文件
         - `html-webpack-plugin`
           - webpack中html插件，用来`自动创建html文件(不要忘记设置参考模板)，并会在html文件中自动引入出口文件`
         - `clean-webpack-plugin`
           - webpack中的清除插件，每次构建都会先清除目录

  3. 根目录下创建webpack的配置文件**`webpack.config.js`**

     - ```javascript
       //引入node.js中的path模块，用于配置webpack的路径
       const path = require("path");
       const HtmlWebpackPlugin = require("html-webpack-plugin");
       const { CleanWebpackPlugin } = require("clean-webpack-plugin");
       
       module.exports = {
           optimization:{
               minimize: false // 关闭代码压缩，可选
           },
       	//指定入口文件
           entry: "./src/index.ts",
           
           devtool: "inline-source-map",
           
           devServer: {
               contentBase: './dist'
           },
       	//指定打包的出口文件
           output: {
               //出口文件所在目录
               path: path.resolve(__dirname, "dist"),
               //出口文件的名称
               filename: "bundle.js",
               // 告诉webpack不使用箭头函数。因为虽然在后面使用了babel兼容了低版本浏览器，使得代码里的箭头函数被转换成了普通函数。但是webpack在打包的时候最外层有个箭头函数，这个没法被转化，所以需要使用以下代码
               environment: {
                   arrowFunction: false, // 关闭webpack的箭头函数，可选
                   const: false //关闭const，兼容ie10浏览器
               }
           },
       
           //import的时候可以不用写后缀，webpack会根据这个后缀去查找
           resolve: {
               extensions: [".ts", ".js"]
           },
           
           module: {
               rules: [
                   {
             			//test指定的是要应用该loader的文件名          
                       test: /\.ts$/,
                       //使用的loader
                       use: {
                          loader: "ts-loader"     
                       },
                       //因为webpack是挨个挨个文件夹查找指定的文件名称，这个用于排除不需要查找的文件夹名称，提高查找效率
                       exclude: /node_modules/
                   }
               ]
           },
       
           plugins: [
               new CleanWebpackPlugin(),
               new HtmlWebpackPlugin({
                   title:'TS测试',
                   template: "./src/index.html" //自己设置的参考模板html
               }),
           ],
           
           resolve: {
               extensions: ['.ts', '.js']
           }
       
       }
       ```
  
  4. 根目录下创建**`tsconfig.json(一定要有，否则无法打包)`**，配置可以根据自己需要
  
     - ```json
       {
           "compilerOptions": {
               "target": "ES2015",
               "module": "ES2015",
               "strict": true
           }
       }
       ```
  
  5. 修改**`package.json`**添加如下配置，命令行的命令配置
  
     - ```json
       {
         ...略...
         "scripts": {
           "test": "echo \"Error: no test specified\" && exit 1",
           "build": "webpack",
           "start": "webpack serve --open chrome.exe" //自动开启服务器
         },
         ...略...
       }
       ```
  
  6. 在src下创建ts文件，并在并命令行执行```npm run build```对代码进行编译，或者执行```npm start```来启动开发服务器
  
  6. 打包后，`webpack会自动将打包完成的js引入模板html中`
  
     

## 5、Babel

- 经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合`babel`来对代码进行转换以使其可以`兼容到更多的浏览器`。webpack中的`ts-loader`在打包时可以`将ts转化为js`，而配置`babel`相关则可以`使js代码兼容更低版本的浏览器`。在上述步骤的基础上，通过以下步骤再将babel引入到项目中。

  1. 安装依赖包：
     - ```npm i -D @babel/core @babel/preset-env babel-loader core-js```
     - 共安装了4个包，分别是：
       - @babel/core
         - babel的核心工具
       - @babel/preset-env
         - babel的预定义环境
       - @babel-loader
         - babel在webpack中的加载器
       - core-js
         - core-js用来使老版本的浏览器支持新版ES语法

  2. 修改webpack.config.js配置文件

     - ```javascript
       ...略...
       module: {
           rules: [
               {
                   test: /\.ts$/,
                   use: [
                       //配置babel
                       {
                           //指定加载器
                           loader: "babel-loader",
                           //设置babel
                           options:{
                               //设置预定义的环境
                               presets: [
                                   [
                                       // 指定环境的插件
                                       "@babel/preset-env",
                                       // 配置信息
                                       {
                                           // 要兼容的目标浏览器
                                           "targets":{
                                               "chrome": "58",
                                               "ie": "11"
                                           },
                                           // 指定corejs的版本，例如低版本的ie浏览器是没有promise的，有了corejs，它会自己生成代码来完成promise的功能
                                           "corejs":"3",
                                           // 使用corejs的方式，"useage"表示按需加载
                                           "useBuiltIns": "usage"
                                       }
                                   ]
                               ]
                           }
                       },
                       // 注意ts-loader要在后面，在后面的loader会先被执行。先使用ts-loader将ts代码转化为js，再通过babel将js代码进行低版本转化，使其可以兼容低版本浏览器
                       {
                           loader: "ts-loader",
       
                       }
                   ],
                   exclude: /node_modules/
               }
           ]
       }
       ...略...
       ```
       
     - 如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。
     
     - 注意`ts-loader要在后面`，在`后面的loader会先被执行`。先使用ts-loader将ts代码转化为js，再通过babel将js代码进行低版本转化，使其可以兼容低版本浏览器
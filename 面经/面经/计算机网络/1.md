## 1.输入一个url发生了什么（描述一次完整的 HTTP 事务）

http://www.baidu.com,这个域名由三部分组成：`协议名`、`域名`、`端口号`，这里端口是默认所以隐藏

1. **`域名解析`**---通过`DNS`服务器对域名进行解析，拿到对应的 IP 地址。`真正访问一个计算机是通过计算机的IP地址进行访问`，但是由于IP地址不好记，用户体验不好，所以就出现"域名"。域名只是与IP地址的一个映射

2. **`建立TCP连接`**---经历`三次握手`，来建立 TCP 连接。

   2.1 第一次握手：`客户端`发送一个带有`SYN(连接请求或连接接受报文)标志的数据包`给`服务端`，我想要给你发送数据，你现在处于正常工作状态吗？

   2.2 第二次握手：`服务端`收到后，`回传`一个带有`SYN/ACK标志的数据包`以示传达确认信息。我当前处于正常工作状态，你可以给我发送数据。

   2.3 第三次握手：最后`客户端再回传一个带ACK标志的数据包`，代表`握手结束，连接成功`。 浏览器通知服务器：好的，我知道了，我要开始发送数据了。

3. **`浏览器发送请求、服务端处理请求`**

   -    TCP 连接成功后，浏览器就可以`通过 http 协议`来向服务器发起请求。
   -    服务器接收到请求后，开始处理请求。处理完成后将结果返回给浏览器。

4. **`关闭 TCP 连接`**--- 客户端接收到服务端发送的数据后，需要通过TCP协议来断开与服务器的连接。经历`四次挥手`，来关闭 TCP 连接。

   - 第一次挥手：`客户端`发送完数据后，向服务端发送一个`请求终止连接 FIN 报文`主动关闭 TCP 连接。我的东西已经发送完成了，我想要断开连接，可以吗？
   - 第二次挥手：`服务端`发送` ACK 报文`，表明已经收到客户端的报文。此时的 TCP 处于半关闭状态，`客户端到服务端的连接释放`你等会儿，我这边还有数据没有发送完成。
   - 第三次挥手：`服务端`发送完数据后，向客户端发送一个请求终止连接 FIN 报文，服务器告诉客户端：我现在处理完成了，可以关闭连接了。
   - 第四次挥手：`客户端`收到 FIN 报文后，会`发送 ACK 报文`。好的，我知道了。

   三次握手和四次挥手都是为了确保数据传递的安全性和完整性。四次挥手后，会等一会儿，确定服务器没有东西传过来，浏览器会断开连接。

5. **`浏览器渲染页面`**---浏览器接收到服务器发送过来的资源数据后，开始对数据进行解析渲染等操作。浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。



## 2.跨域的原因

**`浏览器的同源策略`**：当我们在`一个源（域）`中，`向另一个源（域）发起请求`时，两个源之间的`协议、IP、端口三者必须一致`，则为同源。（`页面`地址和`页面中的请求`的地址、协议、IP、端口三者必须一致。如果`协议、IP、端口`三者中，`有一个不一致`，则为行为`跨域`。浏览器在默认情况下，是`不允许跨域的`。一旦跨域，浏览器就会出现以下报错

``` bash
http://www.woniuxy.com/tc
协议 + 计算机IP + 端口号
```

![image-20220301163756555](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220301163756555.png)

## 3.解决跨域的办法

### 3.1 JSONP

- `发送请求的源`的前端在 jQuery 的 ajax 中添加一个 dataType 属性，值为 `jsonp`：

``` javascript
$.ajax({
    url: 'http://localhost:3000/students/getStudents',
    type: 'get',
    dataType: 'jsonp',
    success(msg) {

    }
})
```

- 在`接收请求的源`的后端将响应 `res.send()` 改成 `res.jsonp()`：

``` javascript
router.get('/getStudents', async function (req, res) {
    const data = await getStudents(req.query);
    res.jsonp(data);
})
```

- JSONP 的方式`只能处理 GET` 请求类型的跨域。



### 3.2 CORS

CORS 解决跨域的方式，是在`接收请求源的服务端`进行设置：

1. 哪些源（域）可以进行跨域访问
2. 允许跨域访问的请求头的属性以及请求类型
3. 设置是否允许cookie发送到服务器

``` javascript
var app = express();

var allowCrossDomain = function (req, res, next) {
  // 设置允许哪一个源（域）可以进行跨域访问，* 表示所有源
  res.header("Access-Control-Allow-Origin", "*");
  // 设置允许跨域访问的请求头的属性
  res.header("Access-Control-Allow-Headers", "X-Requested-With,Origin,Content-Type,Accept,Authorization");
  // 设置允许跨域访问的请求类型
  res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");
  // 设置允许 cookie 发送到服务器 
  res.header('Access-Control-Allow-Credentials', 'true');
  next();
};
app.use(allowCrossDomain); // 使用该中间件
```



### 3.3 代理服务器(Node中间层)

因为`浏览器`存在一个`同源策略`，所以会出现`跨域`问题。可以`让请求先发到同源的中间层`，`再由中间层向别的源请求数据`

`前端发送 ajax 请求到代理服务器`，代理服务器需要将该请求再转发到目标服务器

注意服务器会接收到请求，并进行响应，但是响应内容被AJAX引擎拦截



## 4.强缓存和协商缓存，如果想要不缓存，怎么设置



### 4.1 缓存是什么

缓存就是一个**`资源副本`。**当我们向服务器请求资源后，会根据情况将资源 copy 一份副本存在本地，以方便下次读取

缓存最根本的作用就是**`减少没必要请求`**。有些资源，比如用户头像图片，很久才改变一次，但每次都要去请求这张一样的图片，通信一来一回增加了页面的显示时长，过多没必要请求也增加了服务器的压力。如果把这张图片直接缓存在本地，那每次就可以直接本地读取加载，不再发起请求。所以缓存的好处也就显而易见了，**减少了时长从而优化用户体验，也减少了流量消耗，减轻了服务器的压力**。



### 4.2 HTTP Cache

分为强缓存和协商缓存。

1. **`强缓存`**：直接`从本地副本比对读取`，**`不去请求服务器`**，返回的状态码是 **`200`**。
2. **`协商缓存`**：**`会去服务器比对`**，若没改变才直接读取本地缓存，返回的状态码是 **`304`**。



#### 4.2.1 强缓存

当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，

强缓存主要包括 `expires` 和 `cache-control`。**访问本地缓存直接验证**看是否过期，如果没过期直接使用本地缓存，并返回 200。

1. **`expires`**

   当我们请求一个资源，服务器返回时，可以在 `Response Headers` 中增加 `expires` 字段表示资源的过期时间。

   ``` javascript
   expires: Thu, 03 Jan 2019 11:43:04 GMT
   ```

   它是一个**时间戳**（准确点应该叫格林尼治时间），当`客户端再次请求该资源的时候，会把客户端时间与该时间戳进行对比，如果大于该时间戳则已过期，否则直接使用该缓存资源`。

   

2. **`cache-control`**

该字段是一个`时间长度`，单位秒，`表示该资源过了多少秒后失效`。`当客户端请求资源的时候，发现该资源还在有效时间内则使用该缓存`，它**不依赖客户端时间**。`cache-control` 主要有 `max-age` 和 `s-maxage`、`public` 和 `private`、`no-cache` 和 `no-store` 等值。

``` javascript
cache-control: public, max-age=3600, s-maxage=3600 
```

- max-age 和 s-maxage

  表示资源过了多少秒之后变为无效。可以通过设置 `max-age 为 0` 表示立马过期来向服务器请求资源。

- public 和 private

  `public` 表示该资源可以被所有`客户端和代理服务器`缓存，而 `private` 表示该资源仅能`客户端`缓存

- no-cahce和no-store

  `no-cache` 表示的是不直接询问浏览器缓存情况，而是去向服务器**验证**当前资源是否更新（即协商缓存）。`一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的`，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。

  `no-store` 则更狠，**`完全不使用缓存策略，不缓存请求或响应的任何内容，直接向服务器请求最新`**。



#### 4.2.2 协商缓存

上面的 `expires` 和 `cache-control` 就是给资源设置了过期时间，客户端每次请求资源时都会**`访问本地缓存验证`**看`是否过期`，如果没过期直接使用本地缓存，并返回 200。但如果过期了或者设置了 `no-cache` 和 `no-store` 则本地缓存会被忽略，会去**`请求服务器验证`**资源`是否更新`，如果没更新才继续使用本地缓存，此时返回的是 304，这就是协商缓存。

协商缓存主要包括 `last-modified` 和 `etag`。

1. **`last-modified`**

   `last-modified` 记录`资源最后修改的时间`。启用后，请求资源之后的响应头会增加一个 `last-modified` 字段

   ``` javascript
   last-modified: Thu, 20 Dec 2018 11:36:00 GMT
   ```

   当再次请求该资源时，`请求头`中会带有 `if-modified-since` 字段，值是之前返回的 `last-modified` 的值，服务端会对比该字段和资源的最后修改时间，若一致则证明没有被修改，告知浏览器可直接使用缓存并返回 304；若不一致则直接返回修改后的资源，并修改 `last-modified` 为新的值。

2. **`etag`**

​	 `etag` 会`基于资源的内容编码生成一串唯一的标识字符串`，只要内容不同，就会生成不同的 `etag`。启用 `etag` 之后，请求资源后的响应返回会增加一个 `etag` 字段

``` javascript
etag: "FllOiaIvA1f-ftHGziLgMIMVkVw_"
```

当再次请求该资源时，请求头会带有 `if-none-match` 字段，值是之前返回的 `etag`服务端会根据该资源当前的内容生成对应的标识字符串和该字段进行对比，若一致则代表未改变可直接使用本地缓存并返回 304；若不一致则返回新的资源（状态码200）并修改返回的 `etag` 字段为新的值。



### 4.3 过程总结

每次请求返回来 `response header` 中的 `etag和 last-modified`，在下次请求时在 request header 就把这两个带上，服务端把你带过来的标识进行对比，然后判断资源是否更改了，如果更改就直接返回新的资源，和更新对应的response header的标识etag、last-modified。如果资源没有变，那就不变etag、last-modified，这时候对客户端来说，每次请求都是要进行协商缓存了

**`发请求-->客户端看资源是否过期(expires、cache-control)-->过期-->请求服务器-->服务器对比资源是否真的过期(last-modified、etag)-->没过期-->返回304状态码-->客户端用缓存的老资源。`**

**`发请求-->客户端看资源是否过期(expires、cache-control)--->过期-->请求服务器-->服务器对比资源是否真的过期(last-modified、etag)-->过期-->返回200状态码-->客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等。`**



## 5.常见的HTTP状态码

### 5.1 大概分类

- 1xx 代表某个消息 ，一般意思就是请求已被接受，需要继续处理。

- **`2xx`** 代表`本次请求成功`，请求已成功被服务器接收、理解、并接受。其中 200 是我们比较常见的

- **`3xx`** `重定向`，代表需要`客户端采取进一步的操作才能完成请求`。
- **`4xx`** `客户端错误`，代表了`客户端看起来可能发生了错误，妨碍了服务器的处理`，十分常见。
- **`5xx`** `服务器错误` ，表示`服务器无法完成明显有效的请求`。服务器`在处理请求的过程中有错误或者异常状态发生`，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理，这类型的状态码也十分常见



### 5.2 常见状态码

1. **`200 ok`**

   ---`请求已成功`，请求所希望的响应头或数据体将随此响应返回。

2. **`400 Bad Request`**

   --- 由于明显的`客户端错误`（例如，格式错误的请求语法，太大，无效的请求消息或欺骗性路由请求），`服务器不能或不会处理该请求`。

3. **`403 Forbidden`**

   --- `服务器已经理解请求，但是拒绝执行它`。如果服务器能够讲清楚为何请求不能被执行，那么会在实体内描述拒绝的原因，当然，如果服务器不希望让客户端获得任何信息，就直接给你一个 404

4. **`404 Not Found`**

   --- `请求失败`，`请求所希望得到的资源未被在服务器上发现`，但允许用户的后续请求。

5. **`500 Internal Server Error`**

   --- `通用错误消息`，`服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理`。没有给出具体错误信息。

6. **`501 Not Implemented`**

   --- `服务器不支持当前请求所需要的某个功能`。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。（例如，网络服务API的新功能）

7. **`502 Bad Gateway`**(问到)

   --- 作为`网关或者代理工作的服务器尝试执行请求`时，`从上游服务器接收到无效的响应`。

8. **`503 Service Unavailable`**

   --- `由于临时的服务器维护或者过载，服务器当前无法处理请求`。`这个状况是暂时的，并且将在一段时间以后恢复`，如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。

9. **`504 Gateway Timeout`**(问到)

   --- 作为`网关或者代理工作的服务器尝试执行请求时`，`未能及时从上游服务器（URI标识出的服务器，例如[HTTP](https://so.csdn.net/so/search?q=HTTP&spm=1001.2101.3001.7020)、FTP、LDAP）或者辅助服务器（例如DNS）收到响应`。

10. **`505 HTTP Version Not Supported`**

    --- 服务器不支持，或者拒绝支持在请求中使用的HTTP版本

​	

## 6.请求方法，option用在什么场景

![image-20220304095654539](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220304095654539.png)

1、**`OPTIONS`**

返回`服务器针对特定资源所支持的HTTP请求方法`;`跨域请求`中，`options请求是浏览器自发起的preflight request(预检请求)`，以`检测实际请求是否可以被浏览器接受。`

2、HEAD

向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。

3、**`GET`**

向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url

4、**`POST`**

向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form

5、PUT

向指定资源位置上传其最新内容

6、DELETE

请求服务器删除Request-URL所标识的资源

7、TRACE

回显服务器收到的请求，主要用于测试或诊断

8、CONNECT

HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。



## 7.讲一下cookie、session、localStorage、sessionStorage

### **`7.1 cookie`**:

-  浏览器向服务器发送请求后，`服务器在响应头里面添加一个 Set-Cookie 字段`，浏览器收到响应后保存该字段。`此后每次浏览器访问该服务器，都必须带上这段数据`。一般用于识别用户身份，记录历史记录啊等等
- 如果`不在浏览器中设置过期事件`，cookie被保存在内存中，`生命周期随浏览器的关闭而结束`，这种cookie简称为会话cookie。如果在浏览器中`设置了cookie的过期事件`，cookie会被保存在硬盘中，`关闭浏览器后，cookie数据仍然存在，直到过期事件结束才消失`

<img src="https://segmentfault.com/img/bVbj8Vv?w=1049&h=651" alt="cookie原理" style="zoom:70%;" />

localStorage和sessionStorage都是本地存储，将数据存储在本地浏览器中。区别是localStorage需要手动删除，而sessionStorage浏览器关闭即可删除

### 7.2 `session`：

- 一般来说，Session 基于 Cookie 来实现。`使用cookie方式存储sessionid到客户端`
- `客户端访问服务器时`，服务器读取 SessionID。服务器有一块内存（哈希表）保存了所有 session。通过 SessionID 我们可以得到对应用户的隐私信息，如 id、email

### 7.3 localStorage

- `数据存储在用户浏览器`中
- `声明周期永久生效，除非手动删除 否则关闭页面也会存在`
- 



### 7.4 sessionStorage

- **`生命周期为关闭浏览器窗口`**！！！也就是说关闭浏览器再打开此页面便没有数据了
- `数据存储在用户浏览器`中

localStorage和sessionStorage都`保存在客户端，不与服务器进行交互通信`。获取数据可以直接从这两个中获取，不需要频繁发送请求。存储空间相对于cookie也更大

# 组件实例三大核心属性

## 1. state(状态)

### 1.1 什么是state

- `组件的状态里的数据会驱动页面的展示`
- 通过与用户的交互，实现不同的状态，然后去渲染UI,这样就让用户的数据和界面保持一致了
- 在React中，更新组件的state，结果就会重新渲染用户界面(不需要操作DOM),一句话就是说，`用户的界面会随着状态的改变而改变`。
- **`数据变化，state发现变化，生成虚拟DOM，重新渲染页面。state如何发现变化，需要将数据存入state里`**
- state 只能在本组件中去初始化，并且 state 只能被本组件去修改和仿问，不能被外部仿问和修改，所以也可以说，`state 是组件私有的`。
- this.state的值是一个对象，因为state里存储的是数据，一个组件里数据可能有多种。所以key是数据名称，value是数据值
- ![image-20220123113327769](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220123113327769.png)

### 1.2 state初始化

在`constructor构造函数`中进行初始化

``` html
<body>
    <div id="test"></div>
    <script type="text/babel">
        // 定义类式组件
        class Weather extends React.Component {
            constructor(props) {
                super(props);
                this.state = { weather: '炎热', isHot: false };
            }
            render() {
                let { isHot } = this.state; //通过结构赋值匹配上state的isHot属性，并把属性值给isHot变量
                return <h1>今天天气{isHot ? '炎热' : '凉爽'}</h1>;
            }
        }
        // 调用组件生成实例，将实例渲染到页面上
        ReactDOM.render(<Weather />, document.querySelector('#test'));
    </script>
</body>
```

![image-20220121172839300](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220121172839300.png)

### 1.3 React中绑定监听事件

#### 1.3.1 以前学习中给DOM绑定监听事件的三种方式

1. btn.onclick

   ```javascript
   <body>
       <button id="test">Click me !</bu>
           <script type="text/babel">
               let btn = document.getElementById('test');
               btn.onclick = () => {
                   alert(1);
               }
           </script>
   </body>
   ```

   

2. btn.addEventListener

   -  btn.addEventListener(`'click'`, () => {
                     alert(1);
                 })
   - 是`字符串 `

   ``` javascript
   <body>
       <button id="test">Click me !</bu>
           <script type="text/babel">
               let btn = document.getElementById('test');
               btn.addEventListener('click', () => {
                   alert(1);
               })
           </script>
   </body>
   ```

   

1. 直接在节点属性上绑定
   - onclick=**`"show()"`**
   - 注意是用`双引号括起来`

``` javascript
<body>
    <button id="test" onclick="show()">Click me !</bu>
        <script type="text/babel">
            function show() {
                alert(1);
            }
        </script>
</body>
```

#### 1.3.2 给虚拟节点绑定监听事件的三种方式

1. h1.onclick

   - 注意`绑定事件一定要在将节点渲染到页面之后`。
   - 要**`页面上已经有了节点`**，`才能够获取节点绑定事件`

   ```javascript
   <body>
       <div id="test"></div>
       <script type="text/babel">
           // 创建类式组件
           class Demo extends React.Component {
               constructor(props) {
                   super(props);
                   this.state = { isHot: true };
               }
               render() {
                   // 返回虚拟节点
                   let { isHot } = this.state;
                   return <h1 id="h1">今天天气很{isHot ? '炎热' : '凉爽'}</h1>
               }
           }
   
           // 渲染
           ReactDOM.render(<Demo />, document.getElementById('test'));
   
           let h1 = document.querySelector('#h1');
           h1.onclick = () => {
               alert(1);
           }
       </script>
   </body>
   ```

   

2. btn.addEventListener

   -  btn.addEventListener(`'click'`, () => {
                     alert(1);
                 })
   - 是`字符串 `

   ``` javascript
   <body>
       <div id="test"></div>
       <script type="text/babel">
           // 创建类式组件
           class Demo extends React.Component {
               constructor(props) {
                   super(props);
                   this.state = { isHot: true };
               }
               render() {
                   // 返回虚拟节点
                   let { isHot } = this.state;
                   return <h1 id="h1">今天天气很{isHot ? '炎热' : '凉爽'}</h1>
               }
           }
   
           // 渲染
           ReactDOM.render(<Demo />, document.getElementById('test'));
   
           let h1 = document.querySelector('#h1');
           h1.addEventListener('click', () => {
               alert(1);
           })
       </script>
   </body>
   ```

   

1. 直接在节点属性上绑定
   - `onClick={show}`
   - 注意不能是{show()}。渲染组件到页面的时候，React会执行{}里的代码，并把`返回值`放到这个位置
   - **`如果是{show()}，React会马上执行show()里的代码`**。**`如果是{show}，就是把函数放在这个位置，点击的时候才会调用函数`**
   - **`这里为什么show可以找到函数，因为show是定义在全局上下文里的`**

``` javascript
<body>
    <div id="test"></div>
    <script type="text/babel">
        // 创建类式组件
        class Demo extends React.Component {
            constructor(props) {
                super(props);
                this.state = { isHot: true };
            }
            render() {
                // 返回虚拟节点
                let { isHot } = this.state;
                return <h1 id="h1" onClick={show}>今天天气很{isHot ? '炎热' : '凉爽'}</h1>
            }
        }

        // 渲染
        ReactDOM.render(<Demo />, document.getElementById('test'));
        function show() {
            alert(1);
        }
    </script>
</body>
```

 ### 1.4 绑定事件回调函数分析

![image-20220122210651282](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220122210651282.png)

##### 1.4.1为什么点击事件的回调函数写在类组件里

- 因为组件的全套功能都在类里，这也是我们使用类组件的意义

##### 1.4.2为什么点击事件的回调函数是`{this.show}`

- 因为将show函数写在类组件里，`show是绑定在weather类的prototype上`，{show}在上下文中是找不到这个函数的

- React如何渲染组件的，会先`创建一个Demo的实例对象`---d（假设为d）。`通过d去调用了render方法`。因此render里的this指向d，所以只能**`通过d.show(实例.show)找到在weather类prototype上的show函数`**

- 如果`想要是{show}` ，那么show函数要定义在外面。但这与组件的设计概念相违背。我们要把与组件相关的所有内容都放在组件里打包。

  ![image-20220122221358993](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220122221358993.png)

  

##### 1.4.3为什么不加小括号this.show()

- 因为jsx会运行{}之间的代码，`加了小括号就会立马执行函数`。
- 这样`点击事件的回调就是函数的执行结果而不是函数`
- 不加小括号就是指定函数。

##### 1.4.4为什么会绑定this.show后，点击，函数里的this丢失

- React在读取到`<h1 id="h1" onClick={this.show}>今天天气很{isHot ? '炎热' : '凉爽'}</h1>`后，实际上内部用了一个变量假设为x，类似于x=this.show，因此x也指向了Demo类原型上的show函数。
- 每次点击其实是x()，并没有通过实例进行调用。而在**`直接调用`**类中定义的方法时，浏览器在运行时，全部加上了`use strict`。因此`指向了undefined`。

### 1.5 解决this指向丢失问题

![image-20220123094615822](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220123094615822.png)

- 首先看右边`this.changeWeather.bind(this)`。React在渲染组件时，会先`创建一个Demo的实例对象`---d（假设为d），`在创建实例对象的时候，就会调用constructor函数，因此构造函数里的this指向实例d`。**`实例其实是没有changeWeather这个方法的，但是可以通过_proto_找到Demo类原型上的changeWeather方法`**。
- 所以`this.changeWeather.bind(this)`实际上是找到了Demo类原型上的changeWeather方法，并改变了它的this指向，参数this就是构造器的this也就是实例d，`返回给左边一个this指向实例的changeWeather函数`(关于构造器的this为什么指向实例，可以看上文)
- `左边实际上就是给实例绑定一个changeWeather属性`，`属性值就是右边返回的改变了this指向的changeWeather函数`。所以这一行代码后，实例d有了changeWeather属性

![image-20220123100803942](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220123100803942.png)

### 1.6 改变数据后的页面驱动流程

![image-20220123101232011](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220123101232011.png)

- 点击h1，调用实例对象d上的changeWeather函数`(实例和Demo类都有，实例的是改变了this的，使实例指向this)`。changeWeather函数改变了state里的数据(图中有误，应该是`this.state.isHot = true`)。因为虚拟节点中用到了this.state.isHot，因为其发生了改变，所以驱动页面重新渲染

### 1.7 setState改变state里的数据

正常直接修改一个绑定在实例上的属性值如下，但这样state和其它属性并没有区别。

![image-20220123111839148](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220123111839148.png)

> 严重注意：state不可以直接修改，要用setState去修改

##### 1.7.1 setState分析

通过setState改变实例中sate属性的语法，类似于给this.state赋值

``` javascript
this.setState({ isHot: !this.state.isHot });
```

也是输入一个对象。`key是想要修改的this.state里数据的名称，value是数据修改后的值`

- 实例上并没有setState方法，通过proto找到Weather类的原型对象prototype，发现也没有setState方法。然后再通过Weather类的proto找到继承的React.Component类的prototype，找到了setState方法。
- 可以 看出原型链的重要性，即使实例没有该属性方法，仍能通过原型链找到。

![image-20220123112302233](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220123112302233.png)

### 1.8 state的简写方式

我们可以将state初始化，直接写成类里的赋值语句，也可以绑定到对象中

同时将一般方法也写成赋值语句，放在类里如下图所示

![image-20220123144130823](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220123144130823.png)

**`但会发现this指向的undefined，这是babel造成的`**

但是把函数换成箭头函数就可以解决这个问题。

**`组件类中程序员定义的事件回调，必须写成赋值语句+箭头函数，避免了this为undefined问题，使得this指向实例`**

**`箭头函数里的this指向实例`**。**`类里的赋值语句就是给实例绑上属性`**

![image-20220123144802923](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220123144802923.png)

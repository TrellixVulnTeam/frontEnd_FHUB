## 1.计算机网络

### 1.1 DNS

浏览器的DNS缓存、操作系统的DNS缓存、本地域名服务器的DNS缓存、根域名服务器、顶级域名服务器、权限域名服务器



### 1.2 TCP可靠性

校验和、序列号和确认应答、超时重传、流量控制(数据缓冲区)、拥塞窗口(阈值)



### 1.3 网络模型

物理层(将数据转换成光电信号进行传输)

链路层(物理层面上互连的节点之间的通信传输)

网络层(寻址和路由选择，将数据传输到目标地址)

传输层(TCP,管理两个节点之间的数据传输)

会话层(建立和断开通信连接)

表示层(数据格式的转换)

应用层(http,为应用程序提供服务，拿到数据)



### 1.4 https加密方式

CA机构，服务器认证自己的公钥，然后非对称加密传输密钥，拿到密钥后是对称加密



### 1.5 强缓存、协商缓存

expires、cache-control

last-modified、etag



### 1.6 cookie session

客户端，服务器



### 1.7 http 1.0 1.1 2.0

1.0: 无状态无连接，每次发送请求都要建立一次TCP连接，因为规定下一个请求必须在上一个请求的响应到达才能发送导致队头堵塞

1.1：长连接，增加了一个Connection字段，通过设置[Keep-alive](https://juejin.cn/post/6963931777962344455#keepAlive)（默认已设置）可以保持连接不断开如果客户端想关闭HTTP连接，可以在请求头中携带`Connection:false`来告知服务器关闭请求；同时支持请求管道化，请求虽然能够并行发送，但是响应仍然需要按照请求的顺序返回，即使某个资源先准备好，但因为顺序也得等，因此仍然是没有解决对头堵塞问题

2.0：`二进制分帧`：将请求和响应数据分解为更小的帧，并采用二进制编码；`多路复用`：同域名下的所有通信都在单个连接中完成，单个连接可以承载任意数量的双向数据流，数据流以消息的形式发送，消息就是由多个帧组成的，可以乱序发送；`服务器推送`：不用等到客户端发起请求再推送资源，服务器可以主动发送资源；`头部压缩`：使用encoder来减少需要传输的header大小，通讯双方各自`cache`一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

## 2.JS

###  2.1箭头函数和普通函数区别

定义方式、(修改)this、构造函数、prototype、arguments



### 2.2  判断类型

instanceof、typeof、Object.prototype.toString.call、constructor



### 2.3 闭包

一个函数可以用另外一个函数的变量，一般形式是一个函数嵌套一个函数



### 2.4 图片懒加载

第一种方法：通过计算`元素距离浏览器可视区顶部的距离`判断是否到达可视区

----获得可视区高度：viewHeight = window.innerHeight || document.documentElement.clientHeight

----元素距离浏览器可视区顶部的距离：distance = element.offsetTop - document.documentElement.scrollTop = element.getBoundingClientRect().top

---如果distance < viewHeight说明到达可视区，将自定义属性data-src的值给src



第二种方法：利用new IntersectionObserver创建`观察器`

---先设置好观察器，观察器的第一个参数是一个回调函数，回调函数里有两个重要参数entries和self，entries是要观察的所有对象中可见性发生变化组成的数组，self是观察器自身

---通过遍历entries拿到每个对象

​	----接着通过对象.isIntersecting判断对象是否可见，如果可见再通过对象.target拿到图片节点，设置src属性，

​	----最后通过self.unobserve(对象.target)取消观察



### 2.5 CSS动画和JS动画

css：补间，不会阻塞主线程，GPU

js：逐帧，阻塞后面的解析，CPU

## 3.React

### 3.1 组件间通信

props(父子)、订阅和发布(Pubsub)、redux

### 3.2 生命周期

第一次挂载：constructor, componentWillMount,  render, componentDidMount

更新的时候: componentWillReceiveProps, shounldComponentUpdate(setState), componentWillUpdate(forceState), render, componentDidUpdate

卸载组件：componentWillUnmount



第一次挂载：constructor, static getDerivedStateFromProps(props, state), render componentDidMount

更新的时候：getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate

卸载组件：componentWillUnmount

### 3.3 Hooks

useState, useEffect, useRef



### 3.4 VDOM

减少DOM操作次数(合并操作，利用diff只更新变化的节点)、跨平台



### 3.5 diff

对比前后两次的虚拟DOM树，Tree diff(节点是组件-component diff， 节点是标签-element diff)，



### 3.6 key

标识虚拟DOM，先找key(找到-对比，没找到直接更新)

key如果是数组下标索引，会在逆序删除的时候，增加不必要的操作



## 4. webpack

### 4.1  基本配置

入口文件、出口文件、打包模式(开发者模式、生产模式)

loaders：module.rules= [{text:当前loaders要匹配的文件名, rules[用到的loader]}]

plugins：plugins属性里，属性值是一个数组，每一个数组元素对应一个plugin



### 4.2 loaders和plugins区别

loaders：webpack默认只打包js，帮助打包css、less等转换器

plugins：辅助插件，将css代码从打包好的代码分离。

### 5.实现

### 5.1 apply

``` javascript
Function.prototype.myApply = function (thisArg, ...args) {
    // 判断传过来的this是否符合要求
    if (thisArg == null || thisArg == undefined) thisArg = window;
    // 通过对象调用的方式使得函数的this指向thisArg
    thisArg.fn = this;
    let res = null;
    if (args[0].length != 0) {
        res = thisArg.fn(...args[0])
    } else {
        res = thisArg.fn()
    }
    delete thisArg.fn;
    return res;
}

```

### 5.2 call

``` javascript
Function.prototype.myCall = function (thisArg, ...args) {
    if (thisArg == null || thisArg == undefined) thisArg = window;
    // 通过对象调用函数的形式使得函数的this指向调用者thisArg，这个this是函数
    thisArg.fn = this;
    let res = null;
    res = thisArg.fn(...args);
    delete thisArg.fn;
    return res;
}
```

### 5.3 bind

``` javascript
Function.prototype.myBind = function (thisArg, ...args) {
    let fn = this;
    return function () {
        let res = fn.apply(thisArg, [...args, ...arguments]);
        return res;
    }
}
```



### 5.4 deepclone

``` javascript
function deepClone(oriObj) {
    // 1.首先判断是不是引用类型
    if (typeof oriObj == 'object') {
        // 是引用类型准备深克隆
        // 1.1 判断是数组还是对象，准备一个空的进行复制
        let cloneObj = Array.isArray(oriObj) ? [] : {};
        for (let k in oriObj) {
            // 1.2 有可能要复制的属性也是引用类型，所以要进行 深克隆
            cloneObj[k] = deepClone(oriObj[k]);
        }
        return cloneObj

    } else {
        // 不是引用类型，直接返回值
        return oriObj
    }
}
```

 

### 5.5 throttle

``` javascript
function throttle(fn, delay){
    let timer = null;
    return function(...args){
        //阀门是否打开
        if(timer == null){
            //阀门已经打开,占据阀门，关闭阀门
            timer = setTimerout(()=>{
                //时间到后，执行函数
                fn.apply(this, args);
                //执行完毕，开启阀门
                clearTimeout(timer);
                timer = null;
            }, delay)
        }
    }
}
```



### 5.6 debounce

``` javascript
function debounce(fn, delay, immediate){
	let timer = null; //定时器
    //剩余参数，是一个数组
    return function(...args){
        //先清除之前的定时器
        if(timer) clearTimeout(timer);
        
        //判断是否要立即执行
        if(immediate && !timer){
            //将触发事件的节点传递给fn
            fn.apply(this, args)
        }
        
        //开启定时器，用箭头函数，因为箭头函数的this由上下文决定，指向触发节点
        timer = setTimeout(()=>{
            fn.apply(this, args)
        }, delay)
    }
}
```

### 5.7 函数柯里化

``` javascript
// args是剩余参数，是一个数组
function curry(fn, ...args) {
    // 判断fn的参数长度，和args长度大小
    if (fn.length <= args.length) {
        // args是数组，进行参数分解
        return fn(...args)
    } else {
        return function (..._args) {
            return curry(fn, ..._args, ...args);
        }
    }
}
function sum1(a, b, c) {
    return a + b + c
}
let sum = curry(sum1);
console.log(sum(1)(2)(3))
```


## 1.

执行下列选项的程序，输出结果不是undefined的是（） 


- ```
  function fn(a,b){    console.log(b);
  }
  fn(1);
  ```

- ```
  console.log(undefined + 1);
  ```

- ```
  var arr = [];arr.length = 2;arr[0] = 1;console.log(arr[1]);
  ```

- ```
  function fun(){}console.log(fun());
  ```

- 

A：`实参数量大于形参数量，形参的默认值是undefined`。所以多的形参是undefined。 **`console.log(b) 输出 undefined`**

B：`undefined 与 数字相加，会先将undefined转化为数字。Number(undefined) = NaN`。NaN + 1 = NaN。**`console.log(undefined + 1)输出NaN`**

C：**`js不必严格声明数组长度，即使声明了，再添加多余的元素也是可以的`**js允许**`跳跃赋值`**`中间未被赋值的部分均为undefined`

​	**`console.log(arr[1]);输出 undefined`**

D：fun()调用函数，`函数没有return 语句，所以返回值是undefined`。 `console.log(fun()) 输出undefined;`



## 2.

``` javascript
for(let i=0;i<2;i++){
    setTimeout(function(){
    console.log(i)
    },100);
}
for(var i=0;i<2;i++){
    setTimeout(function(){
        console.log(i)
    },100);
}
问：控制台打印的结果是？
```

①Js是单线程的，Settimeout是异步宏任务，所以`代码执行遇到异步的，就放在事件队列中的，等线程中的任务执行完后才会执行事件队列中的任务`。

② let是es6中声明变量的方式，有自己的作用域块，可以放变量，所以let绑定for循环时，每个i都有自己的值. 在这个for循环中就是满足一次条件向事件队列中添加一个打印i的事件，且每个事件中的i有自己的值 ③Var没有作用域块，for循环的变量就会后一个覆盖前一个，当循环完毕时i就只有一个值，又因为for循环的判断条件是不满足跳出，所以i最后是2而不是1 ④这些完了后执行事件队列中的任务，就打印了0122



## 3. 暂时性死区

依据以下JS代码，在位置A打印变量a与在位置B打印变量a各会有怎样的输出？

``` javascript
var a = 1;
function test(){
    // 位置A
class a {}
   // 位置B
}
test();

/*
	var a;
	function test(){
		console.log(a); // class也不会提升，但是作用域内能找到它，未声明之前不能使用，所以报错
		class a{}
		console.log(a) // 打印 class a{}
	}
	test(); // 1.执行test函数
*/
```



## 4. 函数的length属性、位运算、一元运算符、数组reduce方法

以下哪些表达式的值为0？

``` javascript
A. (()=>{}).length
B. 1 & 2
C. +[]
D. [1,2,-3].reduce((a, b) => a - b, 0)
```

A: 函数的`length`属性，存储着`函数的参数个数`。括号里的函数并没有函数体也没有参数，只是一个声明。所以表达式的值为0

B：位运算，1 = 0001; 2= 0010。所以1 & 2 = 0000，表达式值为0

C：`+[]等价于Number([])` = 0;

D： 数组的`reduce`方法

​						a(preVal)    b(current)      a - b(下一轮的preVal)

​		第一轮              0(初始值)      1            -1

​		第二轮              -1            2            -3

​		第三轮              -3            -3            0

所以最终表达式的值为0



A B C D



## 5. 预解析，优先级提升

以下代码执行后，输出结果为（）

``` javascript
var a = 10;
function a(){}
console.log(typeof a)

/*
	var a;
	function a(){}
	console.log(typeof a)  //1.函数提升优先级高于变量提升，因此这里输出 function a(){}
	a = 10;
	console.log(typeof a)  //2. 赋值会覆盖掉函数声明，因此这里输出Number;
*/
```



## 6.

执行以下程序，下列选项中，说法错误的是（）

``` javascript
class Phone{
  constructor(brand){
    this.brand = brand;
}
  call(){}...①
}
function playGame(){console.log("我可以打游戏")};
function photo(){console.log("我可以拍照")};
console.log(typeof Phone);...②
var p = new Phone('华为');
console.log(p.brand);...③

/*
	var p;
	class Phone{
		constructor(brand){
			this.brand = brand;
		}
		call(){}
	}
	function playGame(){}
	function photo(){}
	console.log(typeof Phone) //1.Phone是类，所以这一行输出类
	p = new Phone('华为') //2. p是phone的一个实例对象，p.constructor('华为') p.proto = Phone.prototype, p={brand: '华为', proto:}
	console.log(p.brand) //3. 打印华为
*/
```



## 7. 立即执行函数+this

下面这段JavaScript代码的的输出是什么？

``` javascript
var myObject = {
    foo: "bar",
    func: function() {
        var self = this;
        console.log(this.foo);   
        console.log(self.foo);   
        (function() {
            console.log(this.foo);   
            console.log(self.foo);   
        }());
    }
};
myObject.func();

/*
	myObject.func(); //1.myObject通过.运算符，调用func函数
	func: function(){has //2.此时，函数里的this指向调用者myObject，this存储着对象{foo: "bar", func}的地址。
		var self = this  //3. 因此，self 也存储着对象{foo: "bar", func}的地址
		console.log(this.foo) //4. 打印"bar"
		console.log(self.foo) //5. 打印"bar"
		(function(){
			console.log(this.foo) //6.立即执行函数里的this指向window，所以这里打印undefined
			console.log(self.foo) //7.立即执行函数内部没有self变量，向外找，在外层找到了self变量，所以打印"bar"
		}())
	}
	
	"bar" "bar" undefined "bar"

*/
```


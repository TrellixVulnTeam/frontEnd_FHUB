# 组件实例三大核心属性

## 1.state(状态)

### 1.1什么是state

- `组件的状态里的数据会驱动页面的展示`
- 通过与用户的交互，实现不同的状态，然后去渲染UI,这样就让用户的数据和界面保持一致了
- 在React中，更新组件的state，结果就会重新渲染用户界面(不需要操作DOM),一句话就是说，`用户的界面会随着状态的改变而改变`。
- `数据变化，state发现变化，生成虚拟DOM，重新渲染页面。state如何发现变化，将数据存入state里`
- state 只能在本组件中去初始化，并且 state 只能被本组件去修改和仿问，不能被外部仿问和修改，所以也可以说，`state 是组件私有的`。

### 1.2state初始化

在`constructor构造函数`中进行初始化

``` html
<body>
    <div id="test"></div>
    <script type="text/babel">
        // 定义类式组件
        class Weather extends React.Component {
            constructor(props) {
                super(props);
                this.state = { weather: '炎热', isHot: false };
            }
            render() {
                let { isHot } = this.state; //通过结构赋值匹配上state的isHot属性，并把属性值给isHot变量
                return <h1>今天天气{isHot ? '炎热' : '凉爽'}</h1>;
            }
        }
        // 调用组件生成实例，将实例渲染到页面上
        ReactDOM.render(<Weather />, document.querySelector('#test'));
    </script>
</body>
```

![image-20220121172839300](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220121172839300.png)

### 1.3React中绑定监听事件

#### 1.3.1 以前学习中给DOM绑定监听事件的三种方式

1. btn.onclick

   ```javascript
   <body>
       <button id="test">Click me !</bu>
           <script type="text/babel">
               let btn = document.getElementById('test');
               btn.onclick = () => {
                   alert(1);
               }
           </script>
   </body>
   ```

   

2. btn.addEventListener

   -  btn.addEventListener(`'click'`, () => {
                     alert(1);
                 })
   - 是`字符串 `

   ``` javascript
   <body>
       <button id="test">Click me !</bu>
           <script type="text/babel">
               let btn = document.getElementById('test');
               btn.addEventListener('click', () => {
                   alert(1);
               })
           </script>
   </body>
   ```

   

1. 直接在节点属性上绑定
   - onclick=**`"show()"`**
   - 注意是用`双引号括起来`

``` javascript
<body>
    <button id="test" onclick="show()">Click me !</bu>
        <script type="text/babel">
            function show() {
                alert(1);
            }
        </script>
</body>
```

#### 1.3.2 给虚拟节点绑定监听事件的三种方式

1. h1.onclick

   - 注意`绑定事件一定要在将节点渲染到页面之后`。
   - 要**`页面上已经有了节点`**，`才能够获取节点绑定事件`

   ```javascript
   <body>
       <div id="test"></div>
       <script type="text/babel">
           // 创建类式组件
           class Demo extends React.Component {
               constructor(props) {
                   super(props);
                   this.state = { isHot: true };
               }
               render() {
                   // 返回虚拟节点
                   let { isHot } = this.state;
                   return <h1 id="h1">今天天气很{isHot ? '炎热' : '凉爽'}</h1>
               }
           }
   
           // 渲染
           ReactDOM.render(<Demo />, document.getElementById('test'));
   
           let h1 = document.querySelector('#h1');
           h1.onclick = () => {
               alert(1);
           }
       </script>
   </body>
   ```

   

2. btn.addEventListener

   -  btn.addEventListener(`'click'`, () => {
                     alert(1);
                 })
   - 是`字符串 `

   ``` javascript
   <body>
       <div id="test"></div>
       <script type="text/babel">
           // 创建类式组件
           class Demo extends React.Component {
               constructor(props) {
                   super(props);
                   this.state = { isHot: true };
               }
               render() {
                   // 返回虚拟节点
                   let { isHot } = this.state;
                   return <h1 id="h1">今天天气很{isHot ? '炎热' : '凉爽'}</h1>
               }
           }
   
           // 渲染
           ReactDOM.render(<Demo />, document.getElementById('test'));
   
           let h1 = document.querySelector('#h1');
           h1.addEventListener('click', () => {
               alert(1);
           })
       </script>
   </body>
   ```

   

1. 直接在节点属性上绑定
   - `onClick={show}`
   - 注意不能是{show()}。渲染组件到页面的时候，React会执行{}里的代码，并把`返回值`放到这个位置
   - **`如果是{show()}，React会马上执行show()里的代码`**。**`如果是{show}，就是把函数放在这个位置，点击的时候才会调用函数`**

``` javascript
<body>
    <div id="test"></div>
    <script type="text/babel">
        // 创建类式组件
        class Demo extends React.Component {
            constructor(props) {
                super(props);
                this.state = { isHot: true };
            }
            render() {
                // 返回虚拟节点
                let { isHot } = this.state;
                return <h1 id="h1" onClick={show}>今天天气很{isHot ? '炎热' : '凉爽'}</h1>
            }
        }

        // 渲染
        ReactDOM.render(<Demo />, document.getElementById('test'));
        function show() {
            alert(1);
        }
    </script>
</body>
```

 ### 1.4 分析

![image-20220122210651282](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220122210651282.png)

##### 1.4.1为什么点击事件的回调函数写在类组件里

- 因为组件的全套功能都在类里，这也是我们使用类组件的意义

##### 1.4.2为什么点击事件的回调函数是`{this.show}`

- 因为`show是在weather类的prototype上`，如果show是找不到这个函数的

- React如何渲染组件的，会先`创建一个Demo的实例对象`---d（假设为d）。`通过d去调用了render方法`。因此render里的this指向d，所以只能通过d.show(实例.show)找到在weather类prototype上的show函数

- 如果`想要是{show}` ，那么show函数要定义在外面。但这与组件的设计概念相违背。我们要把与组件相关的所有内容都放在组件里打包。

  ![image-20220122221358993](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220122221358993.png)

  

##### 1.4.3为什么不加小括号this.show()

- 因为jsx会运行{}之间的代码，`加了小括号就会立马执行函数`。
- 这样`点击事件的回调就是函数的执行结果而不是函数`
- 不加小括号就是指定函数。

##### 1.4.4为什么会绑定this.show后，点击，函数里的this丢失

- React在读取到`<h1 id="h1" onClick={this.show}>今天天气很{isHot ? '炎热' : '凉爽'}</h1>`后，实际上内部用了一个变量假设为x，类似于x=this.show，因此x也指向了Demo类原型上的show函数。
- 每次点击其实是x()，并没有通过实例进行调用。而在**`直接调用`**类中定义的方法时，浏览器在运行时，全部加上了`use strict`。因此`指向了undefined`。

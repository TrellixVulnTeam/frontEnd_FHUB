## 1.讲一下CORS（简单请求、非简单请求）

浏览器将**CORS跨域请求**分为简单请求和非简单请求：

只要同时满足一下两个条件，就属于**`简单请求`**
(1)使用下列方法之一：

- head
- get
- post

(2)请求的Heder是

- Accept
- Accept-Language
- Content-Language
- Content-Type: 只限于三个值：
  - application/x-www-form-urlencoded
  - multipart/form-data
  - text/plain

不同时满足上面的两个条件，就属于非简单请求。

### 1.1 简单请求

浏览器发现这次跨域请求是简单请求，就自动在头信息之中，添加一个`Origin`字段；`Origin`字段用来说明请求来自哪个源（协议+域名+端口号）。服务端根据这个值，决定是否同意本次请求。



### 1.2 非简单请求

非简单请求就是那种对服务器有特殊要求的请求，比如请求方法为`PUT`或`DELETE`，或者`Content-Type`字段为`application/json`;

非简单请求的CORS请求，`会在正式通信之前，增加一次HTTP查询请求，称为“预检”请求`(`预检`请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个域。还包括两个特殊字段CORS请求会用到哪些HTTP方法)；浏览器先询问服务器，`当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段`，只有得到肯定答复，浏览器才会发出正式的接口请求，否则就会报错；一旦服务器通过了`预检`请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个`Origin`头信息字段

## 2.跨域的原因

**`浏览器的同源策略`**：当我们在`一个源（域）`中，`向另一个源（域）发起请求`时，两个源之间的`协议、IP、端口三者必须一致`，则为同源。（`页面`地址和`页面中的请求`的地址、协议、IP、端口三者必须一致。如果`协议、IP、端口`三者中，`有一个不一致`，则为行为`跨域`。浏览器在默认情况下，是`不允许跨域的`。一旦跨域，浏览器就会出现以下报错

``` bash
http://www.woniuxy.com/tc
协议 + 计算机IP + 端口号
```

![image-20220301163756555](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220301163756555.png)

## 3.解决跨域的办法

### 3.1 JSONP

- `发送请求的源`的前端在 jQuery 的 ajax 中添加一个 dataType 属性，值为 `jsonp`：

``` javascript
$.ajax({
    url: 'http://localhost:3000/students/getStudents',
    type: 'get',
    dataType: 'jsonp',
    success(msg) {

    }
})
```

- 在`接收请求的源`的后端将响应 `res.send()` 改成 `res.jsonp()`：

``` javascript
router.get('/getStudents', async function (req, res) {
    const data = await getStudents(req.query);
    res.jsonp(data);
})
```

- JSONP 的方式`只能处理 GET` 请求类型的跨域。



### 3.2 CORS

CORS 解决跨域的方式，是在`接收请求源的服务端`进行设置：

1. 哪些源（域）可以进行跨域访问
2. 允许跨域访问的请求头的属性以及请求类型
3. 设置是否允许cookie发送到服务器

``` javascript
var app = express();

var allowCrossDomain = function (req, res, next) {
  // 设置允许哪一个源（域）可以进行跨域访问，* 表示所有源
  res.header("Access-Control-Allow-Origin", "*");
  // 设置允许跨域访问的请求头的属性
  res.header("Access-Control-Allow-Headers", "X-Requested-With,Origin,Content-Type,Accept,Authorization");
  // 设置允许跨域访问的请求类型
  res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");
  // 设置允许 cookie 发送到服务器 
  res.header('Access-Control-Allow-Credentials', 'true');
  next();
};
app.use(allowCrossDomain); // 使用该中间件
```



### 3.3 代理服务器(Node中间层)

因为`浏览器`存在一个`同源策略`，所以会出现`跨域`问题。可以`让请求先发到同源的中间层`，`再由中间层向别的源请求数据`

`前端发送 ajax 请求到代理服务器`，代理服务器需要将该请求再转发到目标服务器

注意服务器会接收到请求，并进行响应，但是响应内容被AJAX引擎拦截




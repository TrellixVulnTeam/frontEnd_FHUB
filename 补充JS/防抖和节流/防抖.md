## 1. 为什么需要防抖

### 1.1 例子

- 比如说有一天我上完课，我说大家有什么问题来问我，我会`等待一分钟`的时间。
- 如果在`一分钟的时间内`，`没有同学问我问题`，那么我就`下课`了；
  - 在此期间，`a同学过来问问题`，并且帮他`解答`，解答完后，我会`再次等待一分钟`的时间看有没有其他同学问问题；
  - 如果我`等待超过了1分钟`，就点击了`下课`（才真正执行这个时间）



- 比如想要搜索一个MacBook：

  - 当我输入m时，为了更好的用户体验，通常会出现对应的联想内容，这些联想内容通常是保存在服务器的，所以需要一次网络请求；

  - 当继续输入ma时，再次发送网络请求；

  - 那么macbook一共需要发送7次网络请求；

  - 这大大损耗我们整个系统的性能，无论是前端的事件处理，还是对于服务器的压力；
- 但是我们需要这么多次的网络请求吗？

  - 不需要，正确的做法应该是在合适的情况下再发送网络请求；
- 比如如果用户`快速的输入一个macbook`，那么只是`发送一次网络请`求；
  - 比如如果用户是`输入一个m想了一会儿`，这个时候m确实应该`发送一次网络请求；`
- 也就是我们应该`监听用户在某个时间，比如500ms内，没有再次触发时间时，再发送网络请求`；



这就是**`防抖`**的操作：

- 只有`在某个时间内，没有再次触发某个函数时，才真正的调用这个函数`；



**`防抖的应用场景`**很多：

- 输入框中`频繁的输入内容`，搜索或者提交信息；
- `频繁的点击按钮`，触发某个事件；
- 监听浏览器滚动事件，完成某些特定操作；
- 用户缩放浏览器的resize事件；

## 2. 定义

不管事件触发频率多高，一定**`在事件触发 n 秒后才执行`**，如果`在一个事件执行的 n秒内又触发了这个事件，就以新的事件的时间为准`，n秒后才执行，总之，`触发完事件 n 秒内不再触发事件，n秒后再执行`。



## 3.手写debounce

思路：

1. `返回一个函数`，这样debounce函数具有通用性，不必为每一个频繁点击的事件绑定回调
2. 每次触发事件时都取消之前的定时器

需要注意问题：

1. `this`指向，通过在返回函数
2. `参数`的传递
3. 是否要立即调用一次

``` javascript
    function debounce(fn, delay, immedia) {
        // 记录timer
        let timer = null;
        // args表示剩余参数，得到的[x1,x2,x3...]
        return function (...args) {
            // 一旦再次触发，清除上一个timer(timer是定时器的序号，即使清除了定时器，序号不会变)
            if (timer) clearTimeout(timer);
			
            //判断是否要立即执行一次，并且没有timer
            if(immedia && !timer){
                fn.apply(this, args);
            }
            
            // 然后开启定时器，若在指定时间里没有再次触发，就调用fn，箭头函数的this指向上下文，而外层函数的this指向调用者，即触发的button
            timer = setTimeout(() => {
                fn.apply(this, args);
            }, delay)
        }
    }
```

通过**`闭包`**保存一个标记(timer)来保存setTimeout返回的值, 每当要触发函数的时候, 需要`先把上一个setTimeout清除掉`, 然后`再创建一个新的setTimeout`, 这样就能保证执行函数后的 wait 间隔内如果还要触发函数, 就不会执行fn



## 4.使用场景

1. 监听resize或scroll，执行一些业务处理逻辑

``` javascript
window.addEventListener('resize', debounce(handleResize, 200));
window.addEventListener('scroll', debounce(handleScroll, 200));
```

用到一些`高频触发`的函数，需要考虑防抖

- window 的 resize、scroll
- mousedown、mousemove
- keyup、keydown ...

1. 搜索输入框，在输入后200毫秒搜索

``` javascript
debounce(fetchSearchData, 200);
```


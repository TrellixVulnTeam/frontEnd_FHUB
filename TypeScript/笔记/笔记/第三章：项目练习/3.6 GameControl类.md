# GameControl

- 游戏控制器类，其可以控制其它的所有类

## 1.思考GameControl类应该具有的属性和方法

### 1.1 属性

- 蛇snake
- 食物food
- 记分牌score_panel
- 蛇的移动方向direction(贪吃蛇是按键后改变方向然后一直移动)
- 游戏是否结束is_live

### 1.2 方法

- 初始化init()，在构造函数调用直接启动游戏

## 2. init方法

- 监听键盘按下事件，改变direction
- 注意this

``` typescript
    // 游戏初始化，调用后游戏开始
    init() {
        // 监控键盘按下事件，移动蛇
        // 这里的this仍然指向GameControl对象，通过this.keydownHandler找到keydownHandler函数
        // 再通过bind方法改变了keydownHandler的this指向，不再指向调用者而是一直指向GameControl对象。
        // 将这改变了this的函数作为回调函数
        document.addEventListener('keydown', this.keydownHandler.bind(this));
    }
    // 按下键盘后的回调，键盘按下回调
    keydownHandler(event: KeyboardEvent) {

        this.direction = event.key;
    }
```

## 3. keydownHandler方法

- 该方法用于==改变蛇的移动方向==，更新`this.direction`，==同时调用run方法开始移动蛇==
- 最好==不在这个方法里面开启定时器==。因为比如升级的时候也需要重新run开启定时器

``` typescript
    // 按下键盘后的回调，键盘按下回调
    keydownHandler(event: KeyboardEvent) {
        // 需要检查event.key的值是否合法(用户是否按了正确的按键)
        if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
            // 修改direction属性
            this.direction = event.key;
            this.run();
        }
    }
```



## 4. run方法

- 在该方法里，根据方向==不断移动蛇==，根据方向等距离改变`this.snake.style.XX`
- 开启定时器不断调用自身移动蛇，用setTimeout不断调用自身run方法。就可以不停移动
- 如果level升级，速度加快，那么就缩小调用run方法的时间
- `this.is_live && setTimeout(this.run.bind(this), 1000 - (this.score_panel.level - 1) * 10);`如果`this.is_live`为`false`，那么这个表达式直接就是`false`了，并不会进入后面那个表达式；而如果`this.is_live`为`true`，会进入到后面的表达式判断是否为`true`，所以后面那个表达式仍然会被执行。同时==根据`this.score_panel.level`来缩短调用方法的时间从而可以加快蛇移动的速度==
- ==注意定时器的回调函数一定是改变了this后的==，因为在时间到了之后，并不是对象调用的回调函数，如果不将对象提前通过bind传递给回调函数，会导致this丢失

``` typescript
    run() {
        switch (this.direction) {
            case 'ArrowUp':
            case 'Up':
                // 向上移动，top减少
                this.snake.Y -= 10;
                break;
            case 'ArrowDown':
            case 'Down':
                // 向下移动，top增加
                this.snake.Y += 10;
                break;
            case 'ArrowLeft':
            case 'Left':
                // 向左移动，left减少
                this.snake.X -= 10;
                break;
            case 'ArrowRight':
            case 'Right':
                // 向右移动，left增加
                this.snake.X += 10;
        }
        // 在游戏仍然在进行中的情况下才开启定时器
        this.is_live && setTimeout(this.run.bind(this), 1000 - (this.score_panel.level - 1) * 10);
    }
```


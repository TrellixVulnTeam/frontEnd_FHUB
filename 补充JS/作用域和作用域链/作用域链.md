# 作用域链

## 1.什么是自由变量

首先认识一下什么叫做 **`自由变量`** 。如下代码中，`console.log(a)`要得到a变量，但是在`当前的作用域中没有定义`a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量 。`自由变量的值如何得到 —— 向父级作用域寻找`

``` javascript
var a = 100
function fn() {
    var b = 200
    console.log(a) // 这里的a在这里就是一个自由变量
    console.log(b)
}
fn()
```



## 2.什么是作用域链

如果父级也没呢？再`一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃`。这种一层一层的关系，就是 作用域链 

``` javascript
var a = 100
function F1() {
    var b = 200
    function F2() {
        var c = 300
        console.log(a) // 自由变量，顺作用域链向父作用域找
        console.log(b) // 自由变量，顺作用域链向父作用域找
        console.log(c) // 本作用域的变量
    }
    F2()
}
F1()
```



## 3.关于自由变量的取值

关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。

``` javascript
var x = 10
function fn() {
  console.log(x)
}
function show(f) {
  var x = 20
  (function() {
    f() //10，而不是20
  })()
}
show(fn)
//  执行函数的时候，可遇到fn()，就到定义fn的那块代码中执行
```

在fn函数中，取自由变量x的值时，要到哪个作用域中取？——**`要到定义fn函数的那个作用域中取`**，**`无论fn函数将在哪里调用`**。



``` javascript
var a = 10
function fn() {
  var b = 20
  function bar() {
    console.log(a + b) //30
  }
  return bar
}
var x = fn(),
  b = 200
x() //bar()

/*
	function fn(){
		function bar(){
			console.log(a  + b)
		}
		var b;
		b = 20;
		return bar
	}
	var  a;
	var x;
	var b
	a= 10;
	x = fn() = bar; // 将fn函数的返回值给x，执行fn函数
	b = 200;
	x() // 执行bar()
	
*/
```

fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了,所以最后的结果是30

## 4. 作用域与执行上下文

JavaScript属于**`解释型`**语言，JavaScript的执行分为：**`解释`**和**`执行`**两个阶段,这两个阶段所做的事并不一样：

### 4.1 解释阶段：

- 词法分析
- 语法分析
- **`作用域规则确定`**



### 4.2 执行阶段：

- **`创建执行上下文`**
- 执行函数代码
- 垃圾回收

JavaScript`解释阶段便会确定作用域规则`，因此**`作用域在函数定义时就已经确定了`**，而不是在函数调用时确定，但是**`执行上下文是函数执行之前创建的`**。**`执行上下文最明显的就是this的指向是执行时确定的`**。而**`作用域访问的变量是编写代码的结构确定的`**。

作用域和执行上下文之间最大的区别是：
**`执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变`**。

`一个作用域下可能包含若干个上下文环境`。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。**`同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值`**。
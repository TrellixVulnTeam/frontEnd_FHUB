## 1.纯React版



## 2. 迷你Redux版

省掉Action Creators;

注意，只有`别的组件也需要用到的属性放在redux`里，自己特有的还是放在自己的state里

![image-20220320154539396](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220320154539396.png)

### 2.1 初始化

#### 2.1.1 建立redux文件夹

redux文件夹里，有一个Store，每一个组件有一个自己的reducer来进行处理

![image-20220320153256612](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220320153256612.png)



#### 2.1.2 store.js

首先要创建store对象，用到redux的api，参数是其关联的reducer

`在一开始初始化时，store会自动调用一次reducer`，传给reducer的参数是(undefined, 没有data的action)

``` javascript
// 该文件是创建整个redux中最为核心的store对象

// 引入createStore函数，用于创建store对象
import { createStore } from 'redux'
import countReducer from './Count_reducer'

// 创建一个store对象，参数是其关联的reducer
const store = createStore(countReducer);

// 暴露store
export default store
```



#### 2.1.3 count-reducer.js

reducer可以**`初始化状态`**、**`加工状态`**

reducer`本质是一个函数`，`从store接收之前的状态和操作对象`，`对状态进行更新`后，`返回给store`

``` javascript
// 定义为Count组件服务的reducer

// reducer可以：初始化状态、加工状态
// 接收store传过来的prevState, action
export default function countReducer(prevState, action) {
    //对action对象进行解构，拿到类型和数据
    const { type, data } = action;

    // 根据操作类型，决定如何操作状态
    switch (type) {
        case 'increment': //如果是加
            return prevState + data
        case 'decrement': //如果是减
            return prevState - data
        default: //既不是加也不是减，说明是初始化啊
            return 0
    }
}

//虽然也可也定义一个变量newState，然后在switch语句里对newState进行更新，最后返回newState。但直接在switch语句里返回数据可能更方便
```



#### 2.1.4 Count.js

引入store，调用store的api进行状态显示

``` html
<h3>当前求和为：{store.getState()}</h3>
```



### 2.2 更新状态

#### 2.2.1 在Count.js中，准备好action对象

- `准备好action`对象，包括操作的类型和数据
- `分发这个action`对象，用到store.dispatch这个API

``` javascript
    increment = () => {
        //获取用户选择的数字
        let { container } = this;
        const value = parseInt(container.current.value);
        //准备一个action对象
        const action = {
            type: 'incremeent',
            data: parseInt(value)
        }
        // 分发这个action
        store.dispatch(action);
    }
```



#### 2.2.2 渲染页面

- `redux会修改自己存储的state，但是并不会调用render`函数帮我们重新渲染页面，所以我们需要自己重新渲染
- 用`store.subscribe(()=>{})`这个API监听，store里存储的状态一旦发生变化，就会触发这个函数，因此在这个函数里重新渲染即可

![image-20220320163239550](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220320163239550.png)



## 3. 完整redux版

### 3.1 添加action creator`s`

- `是一个函数，调用它创建一个action对象`，返回
- `每一个组件，都有一个自己的action_creator`
- 组件调用然后再利用`store.dispatch(action)`API将action对象分发出去

``` javascript
// 该文件用于定义创建action的函数

// 创建action对象
function createIncrementAction(value) {
    return {
        type: 'increment',
        data: value
    }
}

const createDecrementAction = value => ({
    type: 'decrement',
    data: value
})

export {
    createIncrementAction,
    createDecrementAction
}
```



### 3.2 添加常量模块constant.js

- 用于存储action对象中type的值，帮助程序员避免写错单词

``` javascript
```



![image-20220320174604542](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220320174604542.png)



## 4. 完善异步action

- 我们不想在Count组件内，自己计时，时间到了后再将action分发出去

- 我们想实现让redux帮我们计时，时间到了后，进行分发

  ![image-20220320200348496](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220320200348496.png)

### 4.1 完善store

- 给store进行配置，使其可以在`拿到action`时，发现其是`函数`的时候可以`执行它`；如果是`对象`就传递`给reducer`

  ![image-20220320200837050](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220320200837050.png)

- 首先要添加`redux-thunk`包

- 然后在`创建store对象时`，`补充参数`

``` javascript
// 该文件是创建整个redux中最为核心的store对象

// 引入createStore函数，用于创建store对象
import { createStore, applyMiddleware } from 'redux'
// 引入为了Counter组件服务的reducer
import countReducer from './count_reducer'
// 引入用于支持异步action的中间件
import thunk from 'redux-thunk'

// 创建一个store对象，参数是其关联的reducer
const store = createStore(countReducer, applyMiddleware(thunk));

// 暴露store
export default store
```

![image-20220320201101470](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20220320201101470.png)



### 4.2  完善count_action

- 新增一个异步创建action的函数`createIncrementAsyncAction`。
- 该函数，在count组件中被执行，`返回一个函数(在该函数内帮忙计时，创建action，并分发)`，再通过store.dispatch()分发给store
- store发现自己收到的是一个函数后，会将store.dispatch方法作为参数传递给该函数，并执行。函数体内开启定时器，在时间到后，调用dispatch去给store分发一个同步action

``` javascript
//  异步action中通常会开启异步任务，异步任务有结果后，通常会调用dispatch去分发一个同步action
const createIncrementAsyncAction = (value, time) => {
    return (dispatch) => {
        // 开启定时器，时间到后，分发action对象给store
        setTimeout(() => {
            //这里分发的对象。可以通过调用函数得到。
            dispatch(createIncrementAction(value));
        }, time)
    }
}
```



### 4.3 完善Count组件

``` javascript
    incrementAsync = () => {
        //获取用户选择的数字
        let { container } = this;
        let value = parseInt(container.current.value);
        // 得到action函数
        const action = createIncrementAsyncAction(value, 3000);
        // 分发action
        store.dispatch(action)
    }
```

